package database

import (
	"database/sql"
	"fmt"
	"log"
	"time"
)

// GetDB はデータベースに接続し、*sql.DBを返す
func GetDB(user, pass, host, dbname string) (*sql.DB, error) {

	// 環境変数が空でないことを確認するバリデーション
	if user == "" || pass == "" || dbname == "" {
		return nil, fmt.Errorf("missing required environment variables")
	}

	// データベース接続文字列の生成
	dbconn := fmt.Sprintf("%s:%s@tcp(%s:3306)/%s?parseTime=true", user, pass, host, dbname)

	// データベース接続の確立
	db, err := sql.Open("mysql", dbconn)
	if err != nil {
		return nil, fmt.Errorf("Failed to connect database:%w", err)
	}

	var pingErr error
	for i := 0; i < 10; i++ {
		pingErr = db.Ping()
		if pingErr == nil {
			return db, nil
		}
		log.Printf("DB not ready... retrying in 2 seconds (attempt %d/10): %v", i+1, pingErr)
		time.Sleep(2 * time.Second)
	}

	return nil, fmt.Errorf("could not connect to DB after retries: %w", pingErr)
}
package database

import (
	"database/sql"
)

func MakeTable(db *sql.DB) error {
	query := `
	create table if not exists todolist(
    	id integer unsigned auto_increment primary key,
   		task varchar(100) not null,
    	priority varchar(100) not null,
    	status varchar(100) not null,
    	username varchar(100) not null,
    	created_at datetime
	);`

	_, err := db.Exec(query)
	return err
}
package api

import (
	"database/sql"
	"net/http"

	"github.com/gorilla/mux"
	"github.com/rainbow777/todolist/api/middlewares"
	"github.com/rainbow777/todolist/controllers"
	"github.com/rainbow777/todolist/repository"
	"github.com/rainbow777/todolist/services"
)

// muxルーターの生成とルーティング
func NewRouter(db *sql.DB) *mux.Router {
	// 依存関係を注入（DI）レポジトリ→サービス→コントローラー層

	repository := repository.NewMyAppRepository(db)
	service := services.NewMyAppService(repository)
	controller := controllers.NewMyAppController(service)

	// muxルーターを生成
	r := mux.NewRouter()

	// ルーティング登録
	r.HandleFunc("/todo/insert", controller.InsertTaskHandler).Methods(http.MethodPost)
	r.HandleFunc("/todo/gettask/{id:[0-9]+}", controller.GetTaskHandler).Methods(http.MethodGet)
	r.HandleFunc("/todo/getlist", controller.GetListHandler).Methods(http.MethodGet)
	r.HandleFunc("/todo/update/{id:[0-9]+}", controller.UpdateTaskHandler).Methods(http.MethodPatch)
	r.HandleFunc("/todo/delete/{id:[0-9]+}", controller.DeleteTaskHandler).Methods(http.MethodDelete)

	// ミドルウェアを登録（登録順に実行される）
	r.Use(middlewares.LoggingMiddleware) // ロギング
	r.Use(middlewares.AuthHandle)        // ユーザー認証

	return r
}
package middlewares

import (
	"log"
	"net/http"
)

type resLoggingWriter struct {
	http.ResponseWriter
	code int
}

func NewMyResposeWriter(w http.ResponseWriter) *resLoggingWriter {
	return &resLoggingWriter{ResponseWriter: w, code: http.StatusOK}
}

// ハンドラが実行されると、WriteHeadeメソッドが自動で実行されて、ステータスコードがcodeフィールドに格納される
func (rlw *resLoggingWriter) WriteHeader(code int) {
	// レシーバーをポインタにしないとコピー先に値が格納されてしまう

	rlw.code = code
	rlw.ResponseWriter.WriteHeader(code)
}

func LoggingMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {

		log.Println(req.RequestURI, req.Method)

		// レスポンス内容を確認するために自作レスポンスを作成
		rlw := NewMyResposeWriter(w)

		// 自作レスポンスを渡して、次のハンドラを実行
		next.ServeHTTP(rlw, req)

		log.Printf("response code:%d", rlw.code)
	})
}
package middlewares

import (
	"context"
	"errors"
	"net/http"
	"strings"

	"github.com/rainbow777/todolist/envconfig"
	"github.com/rainbow777/todolist/myerrors"
	"google.golang.org/api/idtoken"
)

func ValidateIDtoken(IDtoken string) (string, error) {
	// IDtokenを検証するメソッドを持つ構造体を生成
	validator, err := idtoken.NewValidator(context.Background())
	if err != nil {
		err = myerrors.CannotMakeValidator.Wrap(err, "Failed to make Validator")
		return "", err
	}

	// IDtokenを検証し、ペイロードの情報を入手
	payload, err := validator.Validate(context.Background(), IDtoken, envconfig.AppConfig.GoogleClientID)
	if err != nil {
		err = myerrors.Unauthorizated.Wrap(err, "Failed to validate IDtoken")
		return "", err
	}

	// ペイロード内のユーザー名をリクエストのコンテキストに格納
	username, ok := payload.Claims["name"]
	if !ok {
		err = myerrors.Unauthorizated.
			Wrap(errors.New("invalid req header"), "Failed to get username from the ID token payload")
		return "", err
	}

	return username.(string), nil
}

func AuthHandle(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {

		// リクエストヘッダーからAuthorizationフィールドの情報を入手
		authStr := req.Header.Get("Authorization")

		// AuthorizationフィールドにBearerとIDtokenが格納されているかを確認
		splitAuth := strings.Split(authStr, " ")
		if len(splitAuth) != 2 {
			err := myerrors.RequiredAuthorizationHeader.
				Wrap(errors.New("invalid req header"), "Authorization Header must be two string 「Bearer IDtoken」")
			myerrors.ErrorHandler(w, err)
			return
		}

		if splitAuth[0] != "Bearer" || splitAuth[1] == "" {
			err := myerrors.RequiredAuthorizationHeader.
				Wrap(errors.New("invalid req header"), "Bearer and IDtoken are required")
			myerrors.ErrorHandler(w, err)
			return
		}

		IDtoken := splitAuth[1]

		// IDトークンの検証
		username, err := ValidateIDtoken(IDtoken)
		if err != nil {
			myerrors.ErrorHandler(w, err)
			return
		}

		req = SetUserName(req, username)
		next.ServeHTTP(w, req)
	})

}

func SetUserName(req *http.Request, username string) *http.Request {
	ctx := req.Context()

	ctx = context.WithValue(ctx, userNameKey{}, username)

	return req.WithContext(ctx)
}

func GetUserName(ctx context.Context) string {
	name := ctx.Value(userNameKey{})
	return name.(string)
}

type userNameKey struct{}
package envconfig

import (
	"log"
	"os"
)

type EnvConfig struct {
	DBUser         string
	DBPass         string
	DBName         string
	DBHost         string
	TestDBname     string
	TestDBhost     string
	GoogleClientID string
}

var AppConfig EnvConfig

func LoadEnvConfig() {
	AppConfig = EnvConfig{
		DBUser:         os.Getenv("DB_USER"),
		DBPass:         os.Getenv("DB_PASS"),
		DBName:         os.Getenv("DB_NAME"),
		DBHost:         os.Getenv("DB_HOST"),
		TestDBname:     os.Getenv("TEST_DB_NAME"),
		TestDBhost:     os.Getenv("TEST_DB_HOST"),
		GoogleClientID: os.Getenv("GOOGLE_CLIENT_ID"),
	}

	if AppConfig.GoogleClientID == "" {
		log.Fatal("Error: GoogleClientID must be set")
	}
}
package main

import (
	"log"
	"net/http"

	_ "github.com/go-sql-driver/mysql"
	"github.com/rainbow777/todolist/api"
	"github.com/rainbow777/todolist/database"
	"github.com/rainbow777/todolist/envconfig"
)

func main() {
	// 環境変数ファイル(.env)の読み込み
	envconfig.LoadEnvConfig()

	// データベース接続
	db, err := database.GetDB(
		envconfig.AppConfig.DBUser,
		envconfig.AppConfig.DBPass,
		envconfig.AppConfig.DBHost,
		envconfig.AppConfig.DBName,
	)
	if err != nil {
		log.Fatalf("Error occurred in database.GetDB: %v", err)
	}
	defer db.Close()

	err = database.MakeTable(db)
	if err != nil {
		log.Fatalf("Failed to make todolist table %v", err)
	}

	// ルータの生成とルーティング
	r := api.NewRouter(db)

	log.Println("todo server start at port 8080")
	// サーバー起動
	log.Fatal(http.ListenAndServe(":8080", r))
}
package repository_test

import (
	"database/sql"
	"fmt"
	"log"
	"os"
	"strings"
	"testing"

	_ "embed"

	_ "github.com/go-sql-driver/mysql"
)

func TestMain(m *testing.M) {

	setDB()

	m.Run()

	teardown()
}

var (
	dbUser     string
	dbPass     string
	dbHost     string
	testDBname string
	dbconn     string
	dbPort     string
	testDB     *sql.DB
)

func setDB() {
	getEnv()

	connectDB()
}

func teardown() {
	testDB.Close()
}

func getEnv() {
	dbUser = os.Getenv("DB_USER")
	dbPass = os.Getenv("DB_PASS")
	dbHost = os.Getenv("TEST_DB_HOST")
	dbPort = os.Getenv("TEST_DB_PORT")
	testDBname = os.Getenv("TEST_DB_NAME")

	if dbUser == "" || dbPass == "" || dbPort == "" || testDBname == "" {
		log.Fatalf("missing required environment variables : dbUser, dbPass, dbPort, testDBname")
	}
}

func connectDB() {
	var err error

	// Dockerネットワーク内では、サービス名(dbHost)と内部ポート(3306)を使用して接続する
	dbconn = fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?parseTime=true", dbUser, dbPass, dbHost, dbPort, testDBname)
	testDB, err = sql.Open("mysql", dbconn)
	if err != nil {
		log.Fatalf("fail to connect DB %v", err)
	}

	if err = testDB.Ping(); err != nil {
		log.Fatalf("fail to ping DB %v", err)
	}
}

func prepareTestDB(t *testing.T, filename string) {
	cleanupDB(t)

	setupTestData(t, filename)

	t.Cleanup(func() {
		cleanupDB(t)
	})
}

//go:embed testdata/cleanupDB.sql
var cleanupDBSQL string

//go:embed testdata/insertTestData.sql
var insertTestDataSQL string

//go:embed testdata/gettaskTestData.sql
var gettaskTestDataSQL string

//go:embed testdata/getlistTestData.sql
var getlistTestDataSQL string

//go:embed testdata/updataTestData.sql
var updataTestDataSQL string

//go:embed testdata/deleteTestData.sql
var deleteTestDataSQL string

func cleanupDB(t *testing.T) {
	sqlCommands := readSqlFile(t, "cleanupDB.sql")
	executeSql(t, sqlCommands)
}

func setupTestData(t *testing.T, filename string) {
	sqlCommands := readSqlFile(t, filename)
	executeSql(t, sqlCommands)
}

func getSqlContent(t *testing.T, filename string) string {
	switch filename {
	case "cleanupDB.sql":
		return cleanupDBSQL
	case "deleteTestData.sql":
		return deleteTestDataSQL
	case "getlistTestData.sql":
		return getlistTestDataSQL
	case "gettaskTestData.sql":
		return gettaskTestDataSQL
	case "insertTestData.sql":
		return insertTestDataSQL
	case "updataTestData.sql":
		return updataTestDataSQL
	default:
		t.Fatalf("Unknown SQL file: %s", filename)
		return ""
	}
}

func readSqlFile(t *testing.T, filename string) []string {

	sqlScript := getSqlContent(t, filename)

	return strings.Split(string(sqlScript), ";")
}

func executeSql(t *testing.T, commands []string) {
	for _, command := range commands {
		command = strings.TrimSpace(command)
		if command == "" {
			continue
		}

		_, err := testDB.Exec(command)
		if err != nil {
			t.Fatalf("failed to execute sql: %s err: %v", command, err)
		}
	}
}
package repository

import (
	"database/sql"
	"errors"
	"fmt"
	"strings"

	"github.com/rainbow777/todolist/myerrors"
	"github.com/rainbow777/todolist/structure"
)

// データベースが変更されたかを確認する関数
func CheckAffectedRows(result sql.Result) error {
	affectedRows, err := result.RowsAffected()

	// RowsAffected()関数のエラー処理
	if err != nil {
		wrappedErr := myerrors.NoRowsAffected.Wrap(err, "Failed to check database changes were complete")
		return wrappedErr
	}

	// データベースの変更を確認できなかった場合のエラー処理
	if affectedRows < 1 {
		wrappedErr := myerrors.UnChangeRows.Wrap(errors.New("No affectedRows"), "Database has not changed")
		return wrappedErr
	}

	return nil
}

func GetInsertedTask(r *MyAppRepository, result sql.Result, authUserName string) (structure.Todo, error) {
	// 追加した新規タスクのIDを取得
	id, err := result.LastInsertId()
	if err != nil {
		return structure.Todo{}, myerrors.InsertFailed.Wrap(err, "Error occurred in LastInsertId")
	}
	addedTaskID := int(id)

	// データベースから追加したタスクを取得して、サービス層に返す
	insertedTask, err := r.GetTaskDB(addedTaskID, authUserName)
	if err != nil {
		wrappedErr := myerrors.GetTaskFailed.Wrap(err, "Failed to get last inserted task")
		return structure.Todo{}, wrappedErr
	}
	return insertedTask, nil
}

// Todoリストをデータベースから取得する関数
func GetRows(db *sql.DB, getListRequest structure.GetListRequest) (*sql.Rows, error) {

	baseQuery := "SELECT id, task, priority, status, username, created_at FROM todolist WHERE username = ?"
	args := []any{getListRequest.AuthUserName}

	if getListRequest.Status != "all" {
		baseQuery += " AND status = ?"
		args = append(args, getListRequest.Status)
	}

	if len(getListRequest.Priorities) > 0 {
		questionMarks := make([]string, len(getListRequest.Priorities))
		for i := range questionMarks {
			questionMarks[i] = "?"
		}
		placeholders := strings.Join(questionMarks, ",")

		baseQuery += fmt.Sprintf(" AND priority IN (%s)", placeholders)

		for _, p := range getListRequest.Priorities {
			args = append(args, p)
		}
	}

	baseQuery += " ORDER BY id DESC LIMIT ? OFFSET ?"
	args = append(args, getListRequest.Limit, getListRequest.Offset)

	rows, err := db.Query(baseQuery, args...)
	if err != nil {
		return nil, myerrors.GetListfailed.Wrap(err, "Error occured in db.Query in GetRows func")
	}

	return rows, nil
}

// TodoリストをGo構造体に格納する関数
func ScanRows(rows *sql.Rows) ([]structure.Todo, error) {
	// 複数のタスクデータを格納するため、構造体のスライスを用意
	var todolist []structure.Todo
	// rows内のデータがなくなるまで実行
	for rows.Next() {
		var task structure.Todo
		// タスクの情報を、構造体の各フィールドに格納
		err := rows.Scan(&task.ID, &task.Task, &task.Priority,
			&task.Status, &task.UserName, &task.CreatedAt)
		// エラー処理
		if err != nil {
			return nil, myerrors.ScanFailed.Wrap(err, "Error occurred in rows.Scan in ScanRows Func")
		}

		// タスク情報を格納した構造体をスライスに格納
		todolist = append(todolist, task)
	}

	if err := rows.Err(); err != nil {
		return nil, myerrors.ScanFailed.Wrap(err, "rows iteration error")
	}

	return todolist, nil
}

func MakeQueryAndArgs(updateData *structure.UpdateData) (string, []any, error) {

	var columns []string
	var values []any

	if updateData.UpdateRequest.Task != nil {
		columns = append(columns, "task = ?")
		values = append(values, *updateData.UpdateRequest.Task)
	}

	if updateData.UpdateRequest.Priority != nil {
		columns = append(columns, "priority = ?")
		values = append(values, *updateData.UpdateRequest.Priority)
	}

	if updateData.UpdateRequest.Status != nil {
		columns = append(columns, "status = ?")
		values = append(values, *updateData.UpdateRequest.Status)
	}

	if len(columns) == 0 {
		return "", nil, myerrors.NoUpdateColumn.Wrap(errors.New("No Column to update"),
			"Update column is requred")
	}

	query := fmt.Sprintf("UPDATE todolist SET %s WHERE id = ? AND username = ?",
		strings.Join(columns, ", "))

	arguments := append(values, updateData.TaskID, updateData.AuthUserName)

	return query, arguments, nil

}

func ExecuteUpdate(tx *sql.Tx, query string, arguments []any) error {
	result, err := tx.Exec(query, arguments...)
	if err != nil {
		wrappedErr := myerrors.TaskUpdateFailed.Wrap(err, "Error occurred in tx.Exec")
		return wrappedErr
	}

	err = CheckAffectedRows(result)
	if err != nil {
		return err
	}

	return nil
}

func GetUpdatedTask(tx *sql.Tx, taskID int) (structure.Todo, error) {
	getQuery := "SELECT id, task, priority, status, username, created_at FROM todolist WHERE id = ?"
	row := tx.QueryRow(getQuery, taskID)

	var updatedTask structure.Todo
	err := row.Scan(&updatedTask.ID, &updatedTask.Task, &updatedTask.Priority,
		&updatedTask.Status, &updatedTask.UserName, &updatedTask.CreatedAt)

	if err != nil {
		return structure.Todo{}, myerrors.ScanFailed.Wrap(err, "Error occurred in row.Scan")
	}

	return updatedTask, nil
}
package repository_test

import (
	"database/sql"
	"errors"
	"fmt"
	"testing"
	"time"

	"github.com/DATA-DOG/go-sqlmock"
	_ "github.com/go-sql-driver/mysql"
	"github.com/rainbow777/todolist/repository"
	"github.com/rainbow777/todolist/repository/testdata"
	"github.com/rainbow777/todolist/structure"
	"github.com/stretchr/testify/assert"
)

// 以下、Insert系
func TestInsertTaskDB(t *testing.T) {
	prepareTestDB(t, "insertTestData.sql")

	for _, test := range testdata.InsertTaskTestCases {
		t.Run(test.TestName, func(t *testing.T) {
			repo := repository.NewMyAppRepository(testDB)
			returnedTask, err := repo.InsertTaskDB(test.InsertTask)
			if err == nil {
				assert.Equal(t, test.ExpectedTask.ID, returnedTask.ID, "TaskID is mismatched")
				assert.Equal(t, test.ExpectedTask.Task, returnedTask.Task, "Task Content is mismatched")
				assert.Equal(t, test.ExpectedTask.Priority, returnedTask.Priority, "Priority is mismatched")
				assert.Equal(t, test.ExpectedTask.Status, returnedTask.Status, "Status is mismatched")
				assert.Equal(t, test.ExpectedTask.UserName, returnedTask.UserName, "UserName is mismatched")
			} else {
				t.Errorf("Unexpected Error from InsertTaskDB %v", err)
			}
		})
	}
}

func TestInsertTaskDB_ExecError(t *testing.T) {
	t.Run("Case:Error occured in Exec in InsertTaskDB", func(t *testing.T) {
		db, mock, err := sqlmock.New()
		if err != nil {
			t.Fatalf("Failed to create sqlmock: %v", err)
		}
		defer db.Close()

		mock.ExpectExec("insert into todolist").
			WillReturnError(errors.New("SIMULATED: OrizinalErr from DB.Exec"))

		repo := repository.NewMyAppRepository(db)

		_, err = repo.InsertTaskDB(testdata.TestTaskForInsertErr)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "R001")
		assert.Contains(t, err.Error(), "Error occurred in db.Exec in InsertTaskDB")
		assert.Contains(t, err.Error(), "SIMULATED: OrizinalErr from DB.Exec")
	})

}

func TestInsertTaskDB_RowsAffectedErr(t *testing.T) {
	t.Run("Case:Error occured in result.RowsAffected", func(t *testing.T) {
		db, mock, err := sqlmock.New()
		if err != nil {
			t.Fatalf("Failed to create sqlmock: %v", err)
		}
		defer db.Close()

		mock.ExpectExec("insert into todolist").
			WillReturnResult(sqlmock.NewErrorResult(errors.New("SIMULATED: RowAffected Err")))

		repo := repository.NewMyAppRepository(db)

		_, err = repo.InsertTaskDB(testdata.TestTaskForInsertErr)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "R002")
		assert.Contains(t, err.Error(), "Failed to check database changes were complete")
		assert.Contains(t, err.Error(), "SIMULATED: RowAffected Err")
	})
}

func TestInsertTaskDB_NoRowsAffected(t *testing.T) {
	t.Run("Case:DB RowsAffected returns 0", func(t *testing.T) {
		db, mock, err := sqlmock.New()
		if err != nil {
			t.Fatalf("Failed to create sqlmock: %v", err)
		}
		defer db.Close()

		mock.ExpectExec("insert into todolist").WillReturnResult(sqlmock.NewResult(0, 0))

		repo := repository.NewMyAppRepository(db)

		_, err = repo.InsertTaskDB(testdata.TestTaskForInsertErr)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "R009")
		assert.Contains(t, err.Error(), "Database has not changed")
		assert.Contains(t, err.Error(), "No affectedRows")
	})
}

func TestGetInsertedTask_LastInsertIdError(t *testing.T) {
	t.Run("Case:LastInsertId returns Error in GetInsertedTask in InsertTaskDB", func(t *testing.T) {
		db, _, err := sqlmock.New()
		if err != nil {
			t.Fatalf("Failed to create sqlmock: %v", err)
		}
		defer db.Close()

		repo := repository.NewMyAppRepository(db)
		result := sqlmock.NewErrorResult(errors.New("SIMULATED:LastInsertID Error"))

		_, err = repository.GetInsertedTask(repo, result, "rainbow777")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "R001")
		assert.Contains(t, err.Error(), "Error occurred in LastInsertId")
		assert.Contains(t, err.Error(), "SIMULATED:LastInsertID Error")
	})
}

func TestGetInsertedTask_FailedGetInsertedTask(t *testing.T) {
	t.Run("Case:LastInsertId returns Error in GetInsertedTask in InsertTaskDB", func(t *testing.T) {
		db, mock, err := sqlmock.New()
		assert.NoError(t, err)
		defer db.Close()

		repo := repository.NewMyAppRepository(db)

		mock.ExpectExec("SELECT").WillReturnError(errors.New("SIMULATED: Error occurred in GetTaskDB"))
		result := sqlmock.NewResult(1, 1)

		_, err = repository.GetInsertedTask(repo, result, "rainbow777")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "R004")
		assert.Contains(t, err.Error(), "Error occurred in row.Scan in GetTaskDB")
		assert.Contains(t, err.Error(), "SIMULATED: Error occurred in GetTaskDB")
	})
}

func TestGetInsertedTask_ReturnNoRows(t *testing.T) {
	t.Run("Case:GetTaskDB returns NoRows", func(t *testing.T) {
		db, mock, err := sqlmock.New()
		assert.NoError(t, err)
		defer db.Close()

		mock.ExpectExec("insert into todolist").WillReturnResult(sqlmock.NewResult(1, 1))

		mock.ExpectQuery("SELECT").
			WillReturnRows(sqlmock.NewRows(
				[]string{"id", "task", "priority", "status", "username", "created_at"}))

		repo := repository.NewMyAppRepository(db)

		_, err = repo.InsertTaskDB(testdata.TestTaskForInsertErr)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "R003")
		assert.Contains(t, err.Error(), "Failed to get last inserted task")
		assert.Contains(t, err.Error(), "R004")
		assert.Contains(t, err.Error(), "Error occurred in row.Scan in GetTaskDB")
		assert.Contains(t, err.Error(), "sql: no rows in result set")
	})
}

// Insert系テストここまで------------------------------------------------------------------------------------

// 以下、GetTask系テスト
func TestGetTaskDB(t *testing.T) {
	prepareTestDB(t, "gettaskTestData.sql")

	for _, test := range testdata.GetTaskTestCases {
		t.Run(test.TestName, func(t *testing.T) {
			repo := repository.NewMyAppRepository(testDB)
			got, err := repo.GetTaskDB(test.TaskID, test.AuthUserName)
			assert.NoError(t, err)
			assert.Equal(t, test.ExpectedTask.ID, got.ID, "TaskID is mismatched")
			assert.Equal(t, test.ExpectedTask.Task, got.Task, "Task content is mismatched")
			assert.Equal(t, test.ExpectedTask.Priority, got.Priority, "Priority is mismatched")
			assert.Equal(t, test.ExpectedTask.UserName, got.UserName, "UserName is mismatched")
		})
	}

}

func TestGetTaskDB_ErrQueryRow(t *testing.T) {
	t.Run("Case:Error occurred in QueryRow", func(t *testing.T) {
		db, mock, err := sqlmock.New()
		assert.NoError(t, err)
		defer db.Close()

		mock.ExpectQuery("select").WillReturnError(errors.New("SIMULATED: QueryRow Error"))
		repo := repository.NewMyAppRepository(db)
		_, err = repo.GetTaskDB(1, "rainbow777")
		assert.Error(t, err)
		// assert.Contains(t, err.Error(), "SIMULATED: QueryRow Error")
	})
}

func TestGetTaskDB_ErrorScanRows(t *testing.T) {
	t.Run("Case: ScanRows Error in GetTaskDB", func(t *testing.T) {
		db, mock, err := sqlmock.New()
		assert.NoError(t, err)
		defer db.Close()

		mock.ExpectQuery("select").
			WillReturnRows(sqlmock.NewRows([]string{"id", "task", "priority", "status", "rainbow777"}))

		repo := repository.NewMyAppRepository(db)
		_, err = repo.GetTaskDB(1, "rainbow777")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "R004")
		assert.Contains(t, err.Error(), "Error occurred in row.Scan in GetTaskDB")
		// assert.Contains(t, err.Error(), "sql: no rows in result set")
	})
}

func TestGetTaskDB_Error_NoData(t *testing.T) {
	t.Run("Case: NoData", func(t *testing.T) {
		db, mock, err := sqlmock.New()
		assert.NoError(t, err)
		defer db.Close()

		mock.ExpectQuery("SELECT").
			WillReturnError(sql.ErrNoRows)

		repo := repository.NewMyAppRepository(db)
		_, err = repo.GetTaskDB(999, "rainbow777")
		assert.Error(t, err)
		fmt.Println(err)
		fmt.Println(err.Error())
		assert.Contains(t, err.Error(), "R004")
		assert.Contains(t, err.Error(), "Error occurred in row.Scan in GetTaskDB")
		assert.Contains(t, err.Error(), "sql: no rows in result set")
	})
}

// GetTask系ここまで-------------------------------------------------------------------------------------------

// 以下、GetList系テスト
func TestGetTodolistDB(t *testing.T) {
	prepareTestDB(t, "getlistTestData.sql")
	for _, test := range testdata.GetListTestCases {
		t.Run(test.TestName, func(t *testing.T) {
			repo := repository.NewMyAppRepository(testDB)
			list, err := repo.GetTodolistDB(test.Request)
			assert.NoError(t, err)
			for i, task := range list {
				assert.Equal(t, test.ExpectedList[i].ID, task.ID, "TaskID is unmatched")
				assert.Equal(t, test.ExpectedList[i].Task, task.Task, "Task content is unmatched")
				assert.Equal(t, test.ExpectedList[i].Priority, task.Priority, "Priority is unmatched")
				assert.Equal(t, test.ExpectedList[i].Status, task.Status, "Status is unmatched")
				assert.Equal(t, test.ExpectedList[i].UserName, task.UserName, "UserName is unmatched")
			}
		})
	}
}

func TestGetTodolistDB_Error_GetRows(t *testing.T) {
	requestSlice := []structure.GetListRequest{
		{
			AuthUserName: "rainbow777",
		},
		{
			AuthUserName: "rainbow777",
			Priorities:   []string{"high"},
		},
		{
			AuthUserName: "rainbow777",
			Priorities:   []string{"medium"},
		},
		{
			AuthUserName: "rainbow777",
			Priorities:   []string{"low"},
		},
	}
	for _, request := range requestSlice {
		t.Run("Case: Error Occurred in GetRows", func(t *testing.T) {
			db, mock, err := sqlmock.New()
			assert.NoError(t, err)

			mock.ExpectQuery("SELECT").WillReturnError(errors.New("SIMULATED: db.Query Error"))

			repo := repository.NewMyAppRepository(db)

			_, err = repo.GetTodolistDB(request)
			assert.Error(t, err)
			assert.Contains(t, err.Error(), "R005")
			assert.Contains(t, err.Error(), "Error occured in db.Query in GetRows func")
			assert.Contains(t, err.Error(), "SIMULATED: db.Query Error")
		})
	}
}

func TestGetTodolistDB_Error_ScanRows(t *testing.T) {
	t.Run("Case: Error Occurred in ScanRows", func(t *testing.T) {
		db, mock, err := sqlmock.New()
		assert.NoError(t, err)
		defer db.Close()

		mock.ExpectQuery("SELECT").
			WillReturnRows(
				// int型のコラムidにstring型の値を代入してscanエラーを起こす
				sqlmock.NewRows([]string{"id", "task", "priority", "status", "username", "created_at"}).
					AddRow("invalid_id", "task1", "high", "done", "rainbow777", time.Now()))

		repo := repository.NewMyAppRepository(db)

		_, err = repo.GetTodolistDB(structure.GetListRequest{AuthUserName: "rainbow777"})
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "R004")
		assert.Contains(t, err.Error(), "Error occurred in rows.Scan in ScanRows")
		assert.Contains(t, err.Error(), " sql: Scan error on column index 0")
	})
}

// GetList系テストここまで----------------------------------------------------------------------------------

// 以下 Update系テスト
func TestUpdateTaskDB(t *testing.T) {
	prepareTestDB(t, "updataTestData.sql")

	for _, test := range testdata.UpdateTaskTestCases {
		t.Run(test.TestName, func(t *testing.T) {
			repo := repository.NewMyAppRepository(testDB)
			updatedTask, err := repo.UpdateTaskDB(&test.UpdateData)
			assert.NoError(t, err)
			assert.Equal(t, test.ExpectedTask.ID, updatedTask.ID, "TaskID is unmatched")
			assert.Equal(t, test.ExpectedTask.Task, updatedTask.Task, "Task content is unmatched")
			assert.Equal(t, test.ExpectedTask.Priority, updatedTask.Priority, "Priority is unmatched")
			assert.Equal(t, test.ExpectedTask.Status, updatedTask.Status, "Status is unmatched")
			assert.Equal(t, test.ExpectedTask.UserName, updatedTask.UserName, "UserName is unmatched")
		})
	}
}

func TestUpdateTaskDB_Error_Exec(t *testing.T) {
	t.Run("Case:Error occurred in Exec", func(t *testing.T) {
		db, mock, err := sqlmock.New()
		assert.NoError(t, err)
		mock.ExpectBegin()
		mock.ExpectExec("UPDATE todolist SET").
			WillReturnError(errors.New("SIMULATED: Exec Error"))

		repo := repository.NewMyAppRepository(db)

		_, err = repo.UpdateTaskDB(&testdata.UpdateData)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "R007")
		assert.Contains(t, err.Error(), "Error occurred in tx.Exec")
		assert.Contains(t, err.Error(), "SIMULATED: Exec Error")

		err = mock.ExpectationsWereMet()
		assert.NoError(t, err)
	})
}

func TestUpdateTaskDB_Error_AffectedRows(t *testing.T) {
	t.Run("Case: Error occurred in RowsAffected", func(t *testing.T) {
		db, mock, err := sqlmock.New()
		assert.NoError(t, err)
		mock.ExpectBegin()
		mock.ExpectExec("UPDATE todolist SET").
			WillReturnResult(
				sqlmock.NewErrorResult(errors.New("SIMULATED: RowsAffected Error")))

		repo := repository.NewMyAppRepository(db)
		_, err = repo.UpdateTaskDB(&testdata.UpdateData)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "R002")
		assert.Contains(t, err.Error(), "Failed to check database changes were complete")
		assert.Contains(t, err.Error(), "SIMULATED: RowsAffected Error")

		err = mock.ExpectationsWereMet()
		assert.NoError(t, err)
	})
}

func TestUpdateTaskDB_Error_UnchangeRows(t *testing.T) {
	t.Run("Case: Data is Unchanged", func(t *testing.T) {
		db, mock, err := sqlmock.New()
		assert.NoError(t, err)
		mock.ExpectBegin()
		mock.ExpectExec("UPDATE todolist SET").
			WillReturnResult(
				sqlmock.NewResult(0, 0))

		repo := repository.NewMyAppRepository(db)
		_, err = repo.UpdateTaskDB(&testdata.UpdateData)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "R009")
		assert.Contains(t, err.Error(), "Database has not changed")
		assert.Contains(t, err.Error(), "No affectedRows")

		err = mock.ExpectationsWereMet()
		assert.NoError(t, err)
	})
}

func TestUpdateTaskDB_Error_GetUpdatedTask(t *testing.T) {
	t.Run("Case: Failed to Get updated task", func(t *testing.T) {
		db, mock, err := sqlmock.New()
		assert.NoError(t, err)
		mock.ExpectBegin()
		mock.ExpectExec("UPDATE todolist SET").
			WillReturnResult(sqlmock.NewResult(0, 1))

		mock.ExpectQuery("SELECT").
			WillReturnRows(
				sqlmock.NewRows([]string{"id", "task", "priority", "status", "username", "created_at"}))

		repo := repository.NewMyAppRepository(db)
		_, err = repo.UpdateTaskDB(&testdata.UpdateData)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "R004")
		assert.Contains(t, err.Error(), "Error occurred in row.Scan")
		assert.Contains(t, err.Error(), "sql: no rows in result set")

	})
}

// Update系テストここまで-------------------------------------------------------------------------------------

func TestDeleteTaskDB(t *testing.T) {
	prepareTestDB(t, "deleteTestData.sql")

	for _, test := range testdata.DeleteTaskTestData {
		t.Run(test.TestName, func(t *testing.T) {

			repo := repository.NewMyAppRepository(testDB)
			err := repo.DeleteTaskDB(test.DataInDB.ID, "rainbow777")
			assert.NoError(t, err)

			getQuery := `select * from todolist where id = ?;`
			row := testDB.QueryRow(getQuery, test.DataInDB.ID)
			err = row.Scan()
			assert.Equal(t, sql.ErrNoRows, err, "The data hasn't been deleted")
		})
	}

}

func TestDeleteTaskDB_Error_Exec(t *testing.T) {
	t.Run("Case:Error occurred in Exec", func(t *testing.T) {
		db, mock, err := sqlmock.New()
		assert.NoError(t, err)
		mock.ExpectExec("delete from todolist").
			WillReturnError(errors.New("SIMULATED: Exec Error in DeleteTaskDB"))

		repo := repository.NewMyAppRepository(db)
		err = repo.DeleteTaskDB(1, "rainbow777")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "R008")
		assert.Contains(t, err.Error(), "Failed to delete task")
		assert.Contains(t, err.Error(), "SIMULATED: Exec Error in DeleteTaskDB")
	})
}

func TestTestDeleteTaskDB_Error_RowAffected(t *testing.T) {
	t.Run("Error occurred in RowAffected", func(t *testing.T) {
		db, mock, err := sqlmock.New()
		assert.NoError(t, err)
		mock.ExpectExec("delete from todolist").
			WillReturnResult(sqlmock.NewErrorResult(errors.New("SIMULATED: RowAffected Error")))

		repo := repository.NewMyAppRepository(db)
		err = repo.DeleteTaskDB(1, "rainbow777")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "R002")
		assert.Contains(t, err.Error(), "Failed to check database changes were complete")
		assert.Contains(t, err.Error(), "SIMULATED: RowAffected Error")
	})
}

func TestTestDeleteTaskDB_Error_UnchangeRow(t *testing.T) {
	t.Run("Case: The row is unchanged", func(t *testing.T) {
		db, mock, err := sqlmock.New()
		assert.NoError(t, err)
		mock.ExpectExec("delete from todolist").
			WillReturnResult(sqlmock.NewResult(0, 0))

		repo := repository.NewMyAppRepository(db)
		err = repo.DeleteTaskDB(1, "rainbow777")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "R009")
		assert.Contains(t, err.Error(), "Database has not changed")
		assert.Contains(t, err.Error(), "No affectedRows")
	})
}
package testdata

import (
	"github.com/rainbow777/todolist/myerrors"
	"github.com/rainbow777/todolist/structure"
)

// InsertTaskDB用
var InsertTaskTestCases = []struct {
	TestName     string
	InsertTask   structure.InsertData
	ExpectedTask structure.Todo
}{
	{
		TestName: "case1",
		InsertTask: structure.InsertData{
			Task:         "Insert Test Data 1",
			Priority:     "high",
			Status:       "not_done",
			AuthUserName: "rainbow777",
		},
		ExpectedTask: structure.Todo{
			ID:       1,
			Task:     "Insert Test Data 1",
			Priority: "high",
			Status:   "not_done",
			UserName: "rainbow777",
		},
	},

	{
		TestName: "case2",
		InsertTask: structure.InsertData{
			Task:         "Insert Test Data 2",
			Priority:     "medium",
			Status:       "done",
			AuthUserName: "rainbow777",
		},
		ExpectedTask: structure.Todo{
			ID:       2,
			Task:     "Insert Test Data 2",
			Priority: "medium",
			Status:   "done",
			UserName: "rainbow777",
		},
	},
}

var TestTaskForInsertErr = structure.InsertData{
	Task:         "test",
	Priority:     "high",
	Status:       "done",
	AuthUserName: "rainbow777",
}

var GetTaskTestCases = []struct {
	TestName     string
	TaskID       int
	AuthUserName string
	ExpectedTask structure.Todo
}{
	{
		TestName:     "Case1",
		TaskID:       1,
		AuthUserName: "rainbow777",
		ExpectedTask: structure.Todo{
			ID:       1,
			Task:     "Test Data 1",
			Priority: "high",
			Status:   "not_done",
			UserName: "rainbow777",
		},
	},
	{
		TestName:     "Case2",
		TaskID:       2,
		AuthUserName: "rainbow777",
		ExpectedTask: structure.Todo{
			ID:       2,
			Task:     "Test Data 2",
			Priority: "medium",
			Status:   "done",
			UserName: "rainbow777",
		},
	},
	{
		TestName:     "Case3",
		TaskID:       3,
		AuthUserName: "rainbow777",
		ExpectedTask: structure.Todo{
			ID:       3,
			Task:     "Test Data 3",
			Priority: "low",
			Status:   "not_done",
			UserName: "rainbow777",
		},
	},
}

var GetListTestCases = []struct {
	TestName     string
	Request      structure.GetListRequest
	ExpectedList []structure.Todo
}{
	{
		TestName: "Case1_high",
		Request: structure.GetListRequest{
			AuthUserName: "rainbow777",
			Priorities:   []string{"high"},
			Offset:       1,
			Limit:        20,
		},
		ExpectedList: []structure.Todo{
			{
				ID:       1,
				Task:     "Test Data 1",
				Priority: "high",
				Status:   "not_done",
				UserName: "rainbow777",
			},
			{
				ID:       2,
				Task:     "Test Data 2",
				Priority: "high",
				Status:   "not_done",
				UserName: "rainbow777",
			},
			{
				ID:       3,
				Task:     "Test Data 3",
				Priority: "high",
				Status:   "not_done",
				UserName: "rainbow777",
			},
		},
	},
	{
		TestName: "Case2_medium",
		Request: structure.GetListRequest{
			AuthUserName: "rainbow777",
			Priorities:   []string{"medium"},
			Offset:       1,
			Limit:        20,
		},
		ExpectedList: []structure.Todo{
			{
				ID:       4,
				Task:     "Test Data 4",
				Priority: "medium",
				Status:   "done",
				UserName: "rainbow777"},
			{
				ID:       5,
				Task:     "Test Data 5",
				Priority: "medium",
				Status:   "done",
				UserName: "rainbow777",
			},
		},
	},
	{
		TestName: "Case3_low",
		Request: structure.GetListRequest{
			AuthUserName: "rainbow777",
			Priorities:   []string{"low"},
			Offset:       1,
			Limit:        20,
		},
	},
	{
		TestName: "Case4_NotQuery",
		Request: structure.GetListRequest{
			AuthUserName: "rainbow777",
			Offset:       1,
			Limit:        20,
		},
		ExpectedList: []structure.Todo{
			{
				ID:       1,
				Task:     "Test Data 1",
				Priority: "high",
				Status:   "not_done",
				UserName: "rainbow777",
			},
			{
				ID:       2,
				Task:     "Test Data 2",
				Priority: "high",
				Status:   "not_done",
				UserName: "rainbow777",
			},
			{
				ID:       3,
				Task:     "Test Data 3",
				Priority: "high",
				Status:   "not_done",
				UserName: "rainbow777",
			},
		},
	},
}

func makePointer(s string) *string { return &s }

// update用
var UpdateTaskTestCases = []struct {
	TestName     string
	UpdateData   structure.UpdateData
	ExpectedTask structure.Todo
	ExpectedErr  myerrors.MyAppError
}{
	{
		TestName: "Case1_Success",
		UpdateData: structure.UpdateData{
			TaskID:       1,
			AuthUserName: "rainbow777",
			UpdateRequest: structure.UpdateTaskRequest{
				Priority: makePointer("medium"),
			},
		},
		ExpectedTask: structure.Todo{
			ID:       1,
			Task:     "Test Data 1",
			Priority: "medium",
			Status:   "not_done",
			UserName: "rainbow777",
		},
	},

	{
		TestName: "Case2_Success",
		UpdateData: structure.UpdateData{
			TaskID:       1,
			AuthUserName: "rainbow777",
			UpdateRequest: structure.UpdateTaskRequest{
				Status: makePointer("done"),
			},
		},
		ExpectedTask: structure.Todo{
			ID:       1,
			Task:     "Test Data 1",
			Priority: "medium",
			Status:   "done",
			UserName: "rainbow777",
		},
	},

	{
		TestName: "Case3_Success",
		UpdateData: structure.UpdateData{
			TaskID:       1,
			AuthUserName: "rainbow777",
			UpdateRequest: structure.UpdateTaskRequest{
				Task: makePointer("Updated Data 1"),
			},
		},
		ExpectedTask: structure.Todo{
			ID:       1,
			Task:     "Updated Data 1",
			Priority: "medium",
			Status:   "done",
			UserName: "rainbow777",
		},
	},
	{
		TestName: "Case4_Success",
		UpdateData: structure.UpdateData{
			TaskID:       2,
			AuthUserName: "rainbow777",
			UpdateRequest: structure.UpdateTaskRequest{
				Priority: makePointer("low"),
			},
		},
		ExpectedTask: structure.Todo{
			ID:       2,
			Task:     "Test Data 2",
			Priority: "low",
			Status:   "not_done",
			UserName: "rainbow777",
		},
	},
	{
		TestName: "Case5_Success",
		UpdateData: structure.UpdateData{
			TaskID:       2,
			AuthUserName: "rainbow777",
			UpdateRequest: structure.UpdateTaskRequest{
				Status: makePointer("done"),
			},
		},
		ExpectedTask: structure.Todo{
			ID:       2,
			Task:     "Test Data 2",
			Priority: "low",
			Status:   "done",
			UserName: "rainbow777",
		},
	},
	{
		TestName: "Case6_Success",
		UpdateData: structure.UpdateData{
			TaskID:       2,
			AuthUserName: "rainbow777",
			UpdateRequest: structure.UpdateTaskRequest{
				Task: makePointer("Updated Data 2"),
			},
		},
		ExpectedTask: structure.Todo{
			ID:       2,
			Task:     "Updated Data 2",
			Priority: "low",
			Status:   "done",
			UserName: "rainbow777",
		},
	},
}

var UpdateData = structure.UpdateData{
	TaskID:       1,
	AuthUserName: "rainbow777",
	UpdateRequest: structure.UpdateTaskRequest{
		Task: makePointer("newdata"),
	},
}

// delete用
var DeleteTaskTestData = []struct {
	TestName string
	DataInDB structure.Todo
}{
	{
		TestName: "case1",
		DataInDB: structure.Todo{
			ID:       1,
			Task:     "Test Data 1",
			Priority: "high",
			Status:   "not_done",
			UserName: "rainbow777",
		},
	},
	{
		TestName: "case2",
		DataInDB: structure.Todo{
			ID:       2,
			Task:     "Test Data 2",
			Priority: "medium",
			Status:   "done",
			UserName: "rainbow777",
		},
	},
	{
		TestName: "case3",
		DataInDB: structure.Todo{
			ID:       3,
			Task:     "Test Data 3",
			Priority: "low",
			Status:   "not_done",
			UserName: "rainbow777",
		},
	},
}
package repository

import (
	"context"
	"database/sql"

	"github.com/rainbow777/todolist/myerrors"
	"github.com/rainbow777/todolist/structure"
)

type RepositoryInterFace interface {
	InsertTaskDB(insertData structure.InsertData) (structure.Todo, error)
	GetTaskDB(taskID int, username string) (structure.Todo, error)
	GetTodolistDB(getListRequest structure.GetListRequest) ([]structure.Todo, error)
	UpdateTaskDB(updateData *structure.UpdateData) (structure.Todo, error)
	DeleteTaskDB(taskID int, username string) error
}

type MyAppRepository struct {
	DB *sql.DB
}

func NewMyAppRepository(db *sql.DB) *MyAppRepository {
	return &MyAppRepository{DB: db}
}

// データベースに新規タスクを追加する関数
func (r *MyAppRepository) InsertTaskDB(insertData structure.InsertData) (structure.Todo, error) {
	// クエリ文の生成
	insertQuery := `insert into todolist (task, priority, status, username, created_at) values
		(?,?,?,?,now());`

	// データベースに新規タスクを追加する処理
	result, err := r.DB.Exec(insertQuery, insertData.Task, insertData.Priority,
		insertData.Status, insertData.AuthUserName)

	if err != nil {
		wrappedErr := myerrors.InsertFailed.Wrap(err, "Error occurred in db.Exec in InsertTaskDB")
		return structure.Todo{}, wrappedErr
	}

	// データベースに新規タスクが追加されたかを確認
	err = CheckAffectedRows(result)
	if err != nil {
		return structure.Todo{}, err
	}

	return GetInsertedTask(r, result, insertData.AuthUserName)
}

// 指定したIDのタスクをデータベースから取得する関数
func (r *MyAppRepository) GetTaskDB(taskID int, username string) (structure.Todo, error) {
	// クエリ文の生成
	selectQuery := `SELECT id, task, priority, status, username, created_at FROM todolist WHERE id = ? AND username = ?;`
	// クエリ文を実行して、タスクの情報を取得
	row := r.DB.QueryRow(selectQuery, taskID, username)

	var task structure.Todo
	// データベースから取得したタスク情報をGo構造体の各フィールドに格納する
	err := row.Scan(&task.ID, &task.Task, &task.Priority, &task.Status, &task.UserName, &task.CreatedAt)

	if err != nil {
		wrappedErr := myerrors.ScanFailed.Wrap(err, "Error occurred in row.Scan in GetTaskDB")
		return structure.Todo{}, wrappedErr
	}
	return task, nil
}

// Todoリストを取得してGo構造体に格納する関数
// 優先度の指定が可能
func (r *MyAppRepository) GetTodolistDB(getListRequest structure.GetListRequest) ([]structure.Todo, error) {
	// 自作関数getRowsでTodoリストを取得
	rows, err := GetRows(r.DB, getListRequest)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var todolist []structure.Todo
	// 自作関数scanRows関数でTodoリストをGoの構造体に格納
	todolist, err = ScanRows(rows)
	if err != nil {
		return nil, err
	}
	return todolist, nil
}

// 既存のタスクの情報を変更する関数
func (r *MyAppRepository) UpdateTaskDB(updateData *structure.UpdateData) (todo structure.Todo, err error) {

	tx, err := r.DB.BeginTx(context.Background(), nil)
	if err != nil {
		return structure.Todo{}, err
	}

	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	query, arguments, err := MakeQueryAndArgs(updateData)
	if err != nil {
		return structure.Todo{}, err
	}

	err = ExecuteUpdate(tx, query, arguments)
	if err != nil {
		return structure.Todo{}, err
	}

	todo, err = GetUpdatedTask(tx, updateData.TaskID)
	if err != nil {
		return structure.Todo{}, err
	}

	err = tx.Commit()
	if err != nil {
		return structure.Todo{}, err
	}

	return todo, nil
}

// 指定されたIDのタスクを削除する関数
func (r *MyAppRepository) DeleteTaskDB(taskID int, username string) error {
	//　クエリ文の生成
	deleteQuery := `delete from todolist where id=? AND username = ?`

	// クエリ文の実行
	result, err := r.DB.Exec(deleteQuery, taskID, username)
	if err != nil {
		wrappedErr := myerrors.TaskDeleteFailed.Wrap(err, "Failed to delete task")
		return wrappedErr
	}

	// データベース内が変更されたかを確認
	err = CheckAffectedRows(result)
	if err != nil {
		return err
	}

	return nil
}
package structure

type GetListRequest struct {
	AuthUserName string
	Priorities   []string
	Status       string
	Offset       int
	Limit        int
}
package structure

import (
	"database/sql"
)

type Todo struct {
	ID        int          `json:"id"`
	Task      string       `json:"task"`
	Priority  string       `json:"priority"`
	Status    string       `json:"status"`
	UserName  string       `json:"user_name"`
	CreatedAt sql.NullTime `json:"created_at"`
}
package structure

type UpdateData struct {
	TaskID        int
	AuthUserName  string
	UpdateRequest UpdateTaskRequest
}

type UpdateTaskRequest struct {
	Task     *string `json:"task,omitempty"`
	Priority *string `json:"priority,omitempty"`
	Status   *string `json:"status,omitempty"`
}
package structure

type InsertData struct {
	Task         string `json:"task"`
	Priority     string `json:"priority"`
	Status       string `json:"status"`
	AuthUserName string
}
package services

import (
	"errors"

	"github.com/rainbow777/todolist/myerrors"
	"github.com/rainbow777/todolist/structure"
)

// バリデーション　リクエストの中身を確認
func ValidationRequest(insertData structure.InsertData) error {
	if insertData.Task == "" {
		return myerrors.BadRequest.Wrap(myerrors.ErrRequest, "Please enter the task content")
	}

	if insertData.Priority == "" {
		return myerrors.BadRequest.Wrap(myerrors.ErrRequest, "Please enter the priority")
	}

	if insertData.Priority != "high" && insertData.Priority != "medium" && insertData.Priority != "low" {
		return myerrors.BadRequest.Wrap(errors.New("invalid priority"),
			"Please specify a valid priority")
	}

	if insertData.Status == "" {
		return myerrors.BadRequest.Wrap(myerrors.ErrRequest, "Please enter the status")
	}

	if insertData.Status != "done" && insertData.Status != "not_done" {
		return myerrors.BadRequest.Wrap(errors.New("invalid priority"),
			"Status must be all, done, not_done")
	}

	return nil
}
package services_test

import (
	"database/sql"
	"errors"
	"testing"

	"github.com/rainbow777/todolist/myerrors"
	"github.com/rainbow777/todolist/services/testdata"
	"github.com/rainbow777/todolist/structure"
	"github.com/stretchr/testify/assert"
)

func MakeRepoMockInsert(test testdata.InsertTaskServiceData) *testdata.RepositoryMock {
	var db *sql.DB
	db = nil
	repo := testdata.NewRepositoryMock(db)
	repo.InsertTaskDBClosure = func(insertData structure.InsertData) (structure.Todo, error) {
		if test.ExpectedErr.ErrCode != "" {
			return structure.Todo{}, &test.ExpectedErr
		}
		return test.ExpectedTask, nil
	}
	return repo
}

func CheckReturnedDataInsertTask(t *testing.T, test testdata.InsertTaskServiceData, returnedTask structure.Todo, err error) {
	if err == nil {
		assert.Equal(t, test.ExpectedTask.ID, returnedTask.ID, "TaskID is unmatched")
		assert.Equal(t, test.ExpectedTask.Task, returnedTask.Task, "Task content is unmatched")
		assert.Equal(t, test.ExpectedTask.Priority, returnedTask.Priority, "Priority is unmatched")
		assert.Equal(t, test.ExpectedTask.Status, returnedTask.Status, "Status is unmatched")
		assert.Equal(t, test.ExpectedTask.UserName, returnedTask.UserName, "UserName is unmatched")
	} else {
		var returnedErr *myerrors.MyAppError
		if errors.As(err, &returnedErr) {
			assert.Equal(t, test.ExpectedErr.ErrCode, returnedErr.ErrCode, "Error code is unmatched")
			assert.Equal(t, test.ExpectedErr.Message, returnedErr.Message, "Error Message is unmatched")
		} else {
			t.Fatalf("Failed to change error to MyAppError %v", err)
		}
	}
}

func MakeRepoMockGetTask(test testdata.GetTaskTestData) *testdata.RepositoryMock {
	var db *sql.DB
	db = nil
	repoMock := testdata.NewRepositoryMock(db)
	repoMock.GetTaskDBClosure = func(taskID int, username string) (structure.Todo, error) {
		if test.ExpectedErr.ErrCode != "" {
			return structure.Todo{}, test.RepoReturnErr
		} else {
			return test.ExpectedTask, nil
		}
	}
	return repoMock
}

func CheckReturnedDataGetTask(t *testing.T, test testdata.GetTaskTestData, returnedTask structure.Todo, err error) {

	if err == nil {
		assert.Equal(t, test.ExpectedTask.ID, returnedTask.ID, "Task ID is unmatched")
		assert.Equal(t, test.ExpectedTask.Task, returnedTask.Task, "Task content is unmatched")
		assert.Equal(t, test.ExpectedTask.Priority, returnedTask.Priority, "Priority is unmatched")
		assert.Equal(t, test.ExpectedTask.Status, returnedTask.Status, "Status is unmatched")
		assert.Equal(t, test.ExpectedTask.UserName, returnedTask.UserName, "UserName is unmatched")
	} else {
		var returnedErr *myerrors.MyAppError
		if errors.As(err, &returnedErr) {
			assert.Equal(t, test.ExpectedErr.ErrCode, returnedErr.ErrCode, "ErrCode is unmatched")
			assert.Equal(t, test.ExpectedErr.Message, returnedErr.Message, "Err Message is unmatched")
			assert.Equal(t, test.ExpectedErr.Err.Error(), returnedErr.Err.Error(), "Err Message is unmatched")
		} else {
			t.Fatalf("Failed to change error to MyAppError %v", err)
		}
	}
}

func MakeRepoMockGetList(test testdata.GetListTestData) *testdata.RepositoryMock {
	var db *sql.DB
	db = nil
	repoMock := testdata.NewRepositoryMock(db)
	repoMock.GetTodolistDBClosure = func(getListRequest structure.GetListRequest) ([]structure.Todo, error) {
		if test.ExpectedErr.ErrCode != "" {
			return nil, test.RepoReturnErr
		} else {
			return test.ExpectedTask, nil
		}
	}
	return repoMock
}

func CheckReturnedDataGetList(t *testing.T, test testdata.GetListTestData,
	returnedList []structure.Todo, err error) {

	if err == nil {
		for i, returnedTask := range returnedList {
			assert.Equal(t, test.ExpectedTask[i].ID, returnedTask.ID, "Task ID is unmatched")
			assert.Equal(t, test.ExpectedTask[i].Task, returnedTask.Task, "Task content is unmatched")
			assert.Equal(t, test.ExpectedTask[i].Priority, returnedTask.Priority, "Priority is unmatched")
			assert.Equal(t, test.ExpectedTask[i].Status, returnedTask.Status, "Status is unmatched")
		}
	} else {
		var returnedErr *myerrors.MyAppError
		if errors.As(err, &returnedErr) {
			assert.Equal(t, test.ExpectedErr.ErrCode, returnedErr.ErrCode, "ErrCode is unmatched")
			assert.Equal(t, test.ExpectedErr.Message, returnedErr.Message, "ErrMessage is unmatched")
			assert.Equal(t, test.ExpectedErr.Err, returnedErr.Err, "wrappedErr is unmatched")
		} else {
			t.Fatalf("Failed to change error to MyAppError %v", err)
		}
	}

}

func MakeRepoMockUpdate(test testdata.UpdateTaskTestData) *testdata.RepositoryMock {
	var db *sql.DB = nil
	repoMock := testdata.NewRepositoryMock(db)
	repoMock.UpdateTodoDBClosure = func(updateData *structure.UpdateData) (structure.Todo, error) {
		if test.RepoReturnErr != nil {
			return structure.Todo{}, test.RepoReturnErr
		} else {
			return test.RepoReturnTask, nil
		}
	}
	return repoMock
}

func CheckReturnedDataUpdate(t *testing.T, test testdata.UpdateTaskTestData,
	returnedData structure.Todo, err error) {

	if err == nil {
		assert.Equal(t, test.ExpectedTask.ID, returnedData.ID, "TaskID is unmatched")
		assert.Equal(t, test.ExpectedTask.Task, returnedData.Task, "Task content is unmatched")
		assert.Equal(t, test.ExpectedTask.Priority, returnedData.Priority, "Priority is unmatched")
		assert.Equal(t, test.ExpectedTask.Status, returnedData.Status, "Status is unmatched")
		assert.Equal(t, test.ExpectedTask.UserName, returnedData.UserName, "UserName is unmatched")
	} else {
		var returnedErr *myerrors.MyAppError
		if errors.As(err, &returnedErr) {
			assert.Equal(t, test.ExpectedErr.ErrCode, returnedErr.ErrCode, "ErrCode is unmatched")
			assert.Equal(t, test.ExpectedErr.Message, returnedErr.Message, "Message is unmatched")
			assert.Equal(t, test.ExpectedErr.Err.Error(), returnedErr.Err.Error(), "WrappedErr is unmatched")
		} else {
			t.Fatalf("Failed to change error to MyAppError %v", err)
		}
	}

}

func MakeRepoMockDelete(test testdata.DeleteTaskTestData) *testdata.RepositoryMock {
	var db *sql.DB = nil
	repoMock := testdata.NewRepositoryMock(db)
	repoMock.DeleteTaskDBClosure = func(taskID int, username string) error {
		if test.RepoReturnErr != nil {
			return test.RepoReturnErr
		} else {
			return nil
		}
	}
	return repoMock
}

func CheckReturnedDataDelete(t *testing.T, test testdata.DeleteTaskTestData, err error) {

	if err != nil {
		var returnedErr *myerrors.MyAppError
		if errors.As(err, &returnedErr) {
			assert.Equal(t, test.ExpectedErr.ErrCode, returnedErr.ErrCode, "ErrCode is unmatched")
			assert.Equal(t, test.ExpectedErr.Message, returnedErr.Message, "Message is unmatched")
			assert.Equal(t, test.ExpectedErr.Err, returnedErr.Err, "WrappedErr is unmatched")
		} else {
			t.Fatalf("Failed to change error to MyAppError %v", err)
		}
	}

}
package services

import (
	"database/sql"
	"errors"
	"fmt"

	"github.com/rainbow777/todolist/myerrors"
	"github.com/rainbow777/todolist/repository"
	"github.com/rainbow777/todolist/structure"
)

type ServiceInterFace interface {
	InsertTaskService(insertData structure.InsertData) (structure.Todo, error)
	GetTaskService(taskID int, username string) (structure.Todo, error)
	GetListService(getListRequest structure.GetListRequest) ([]structure.Todo, error)
	UpdateTaskService(updateData *structure.UpdateData) (structure.Todo, error)
	DeleteTaskService(taskID int, username string) error
}

type MyAppService struct {
	Repository repository.RepositoryInterFace
}

// サービス層構造体のコンストラクタ
func NewMyAppService(r repository.RepositoryInterFace) *MyAppService {
	return &MyAppService{Repository: r}
}

// レポジトリ層に新規タスク追加を依頼する関数
func (s MyAppService) InsertTaskService(insertData structure.InsertData) (structure.Todo, error) {

	// リクエストの内容を確認
	err := ValidationRequest(insertData)
	if err != nil {
		return structure.Todo{}, err
	}

	// データベース処理の呼び出し
	addedTask, err := s.Repository.InsertTaskDB(insertData)
	if err != nil {
		err = myerrors.InsertDataFailed.Wrap(err, "Service Error: Failed to insert task to DB")
		return addedTask, err
	}

	// データベースに追加したデータをハンドラ層に返す
	return addedTask, nil
}

// 指定したIDのタスク取得をレポジトリ層に依頼する関数
func (s MyAppService) GetTaskService(taskID int, username string) (structure.Todo, error) {

	// データベース処理の呼び出し
	task, err := s.Repository.GetTaskDB(taskID, username)
	if err != nil {
		// データがなかった場合のエラー処理
		if errors.Is(err, sql.ErrNoRows) {
			Message := fmt.Sprintf("Service Error:  TaskID %d is no data", taskID)
			return structure.Todo{}, myerrors.NAData.Wrap(err, Message)
		}
		// レポジトリ層からエラーが返ってきた場合のエラー処理
		return structure.Todo{}, myerrors.GetDataFailed.Wrap(err, "Failed to get task")
	}
	return task, nil
}

// TodoListの取得をリポジトリ層に依頼する関数
func (s MyAppService) GetListService(getListRequest structure.GetListRequest) ([]structure.Todo, error) {

	// リポジトリ層にTodoListの取得を依頼
	gotTodoList, err := s.Repository.GetTodolistDB(getListRequest)
	if err != nil {
		return []structure.Todo{}, myerrors.GetDataFailed.Wrap(err, "Error occured in GetTodoListDB")
	}

	return gotTodoList, nil
}

// タスク情報の更新をレポジトリ層に依頼する関数
func (s MyAppService) UpdateTaskService(updateData *structure.UpdateData) (structure.Todo, error) {
	// 更新する項目を確認し、更新内容を取得
	if updateData.UpdateRequest.Task == nil &&
		updateData.UpdateRequest.Priority == nil && updateData.UpdateRequest.Status == nil {
		return structure.Todo{}, myerrors.NoUpdateColumn.Wrap(errors.New("No update colomn"),
			"At least one colomn required")
	}

	if updateData.UpdateRequest.Priority != nil {
		if *updateData.UpdateRequest.Priority != "high" &&
			*updateData.UpdateRequest.Priority != "medium" && *updateData.UpdateRequest.Priority != "low" {
			errMessage := fmt.Sprintf("Priority require high or medium or low not %v", *updateData.UpdateRequest.Priority)
			return structure.Todo{}, myerrors.BadRequest.Wrap(errors.New("invalid priority"), errMessage)
		}
	}

	// レポジトリ層にタスクの更新を依頼
	updatedTask, err := s.Repository.UpdateTaskDB(updateData)
	if err != nil {
		return structure.Todo{}, myerrors.UpdateDataFailed.Wrap(err, "Error occurred in UpdateTaskService")
	}

	return updatedTask, nil
}

// 指定されたIDのタスク削除をレポジトリ層に依頼する関数
func (s MyAppService) DeleteTaskService(taskID int, username string) error {

	// リポジトリ層にタスクの削除を依頼
	err := s.Repository.DeleteTaskDB(taskID, username)
	if err != nil {
		return myerrors.DeleteDataFailed.Wrap(err, "Error occurred in DeleteTaskDB")
	}

	return nil
}
package testdata

import (
	"database/sql"
	"errors"

	"github.com/rainbow777/todolist/structure"
)

type RepositoryMock struct {
	DB                   *sql.DB
	InsertTaskDBClosure  func(insertData structure.InsertData) (structure.Todo, error)
	GetTaskDBClosure     func(taskID int, username string) (structure.Todo, error)
	GetTodolistDBClosure func(getListRequest structure.GetListRequest) ([]structure.Todo, error)
	UpdateTodoDBClosure  func(updateData *structure.UpdateData) (structure.Todo, error)
	DeleteTaskDBClosure  func(taskID int, username string) error
}

func NewRepositoryMock(db *sql.DB) *RepositoryMock {
	return &RepositoryMock{DB: db}
}

func (r *RepositoryMock) InsertTaskDB(insertData structure.InsertData) (structure.Todo, error) {
	if r.InsertTaskDBClosure != nil {
		return r.InsertTaskDBClosure(insertData)
	} else {
		return structure.Todo{}, errors.New("InsertTaskDBClosure isn't set up")
	}
}

func (r *RepositoryMock) GetTaskDB(taskID int, username string) (structure.Todo, error) {
	if r.GetTaskDBClosure != nil {
		return r.GetTaskDBClosure(taskID, username)
	} else {
		return structure.Todo{}, errors.New("GetTaskDBClosure isn't set up")
	}
}

func (r *RepositoryMock) GetTodolistDB(getListRequest structure.GetListRequest) ([]structure.Todo, error) {
	if r.GetTodolistDBClosure != nil {
		return r.GetTodolistDBClosure(getListRequest)
	} else {
		return []structure.Todo{}, errors.New("GetTodolistDBClosure isn't set up")
	}
}

func (r *RepositoryMock) UpdateTaskDB(updateData *structure.UpdateData) (structure.Todo, error) {
	if r.UpdateTodoDBClosure != nil {
		return r.UpdateTodoDBClosure(updateData)
	} else {
		return structure.Todo{}, errors.New("UpdateTodoDBClosure isn't set up")
	}
}

func (r *RepositoryMock) DeleteTaskDB(taskID int, username string) error {
	if r.DeleteTaskDBClosure != nil {
		return r.DeleteTaskDBClosure(taskID, username)
	} else {
		return errors.New("DeleteTaskDBClosure isn't set up")
	}
}
package testdata

import (
	"database/sql"
	"errors"

	"github.com/rainbow777/todolist/myerrors"
	"github.com/rainbow777/todolist/structure"
)

type GetTaskTestData struct {
	TestName      string
	RequestID     int
	UserName      string
	ExpectedTask  structure.Todo
	RepoReturnErr error
	ExpectedErr   myerrors.MyAppError
}

var GetTaskTestCases = []GetTaskTestData{
	{
		TestName:  "case1",
		RequestID: 1,
		UserName:  "rainbow777",
		ExpectedTask: structure.Todo{
			ID:       1,
			Task:     "食器洗い",
			Priority: "medium",
			Status:   "not_done",
			UserName: "rainbow777",
		},
	},
	{
		TestName:  "case2",
		RequestID: 2,
		UserName:  "rainbow777",
		ExpectedTask: structure.Todo{
			ID:       2,
			Task:     "タイヤ交換",
			Priority: "high",
			Status:   "not_done",
			UserName: "rainbow777",
		},
	},
	{
		TestName:     "case3",
		RequestID:    3,
		UserName:     "rainbow777",
		ExpectedTask: structure.Todo{},
		RepoReturnErr: &myerrors.MyAppError{
			ErrCode: myerrors.ScanFailed,
			Message: "Error occurred in row.Scan in GetTaskDB",
			Err:     sql.ErrNoRows,
		},
		ExpectedErr: myerrors.MyAppError{
			ErrCode: myerrors.NAData,
			Message: "Service Error:  TaskID 3 is no data",
			Err: &myerrors.MyAppError{
				ErrCode: myerrors.ScanFailed,
				Message: "Error occurred in row.Scan in GetTaskDB",
				Err:     sql.ErrNoRows,
			},
		},
	},

	{
		TestName:     "case4",
		RequestID:    2,
		UserName:     "rainbow777",
		ExpectedTask: structure.Todo{},
		RepoReturnErr: &myerrors.MyAppError{
			ErrCode: myerrors.ScanFailed,
			Message: "Error occurred in row.Scan in GetTaskDB",
			Err:     errors.New("SIMULATED: Orizinal Error from row.Scan"),
		},
		ExpectedErr: myerrors.MyAppError{
			ErrCode: myerrors.GetDataFailed,
			Message: "Failed to get task",
			Err: &myerrors.MyAppError{
				ErrCode: myerrors.ScanFailed,
				Message: "Error occurred in row.Scan in GetTaskDB",
				Err:     errors.New("SIMULATED: Orizinal Error from row.Scan"),
			},
		},
	},
}
package testdata

import (
	"errors"

	"github.com/rainbow777/todolist/myerrors"
	"github.com/rainbow777/todolist/structure"
)

type UpdateTaskTestData struct {
	TestName       string
	UpdateData     structure.UpdateData
	RepoReturnTask structure.Todo // 呼び出し先であるレポジトリ層から返ってくるTask
	ExpectedTask   structure.Todo
	RepoReturnErr  error // 呼び出し先であるレポジトリ層から返ってくるErr
	ExpectedErr    myerrors.MyAppError
}

func makePointer(s string) *string { return &s }

var UpdateTaskTestCases = []UpdateTaskTestData{
	{
		TestName: "case1_Status_Update",
		UpdateData: structure.UpdateData{
			TaskID:       1,
			AuthUserName: "rainbow777",
			UpdateRequest: structure.UpdateTaskRequest{
				Status: makePointer("done"),
			},
		},
		RepoReturnTask: structure.Todo{
			ID:       1,
			Task:     "タイヤ交換",
			Priority: "high",
			Status:   "done",
			UserName: "rainbow777",
		},
		ExpectedTask: structure.Todo{
			ID:       1,
			Task:     "タイヤ交換",
			Priority: "high",
			Status:   "done",
			UserName: "rainbow777",
		},
	},
	{
		TestName: "case2_Task_Update",
		UpdateData: structure.UpdateData{
			TaskID:       1,
			AuthUserName: "rainbow777",
			UpdateRequest: structure.UpdateTaskRequest{
				Task: makePointer("タイヤ交換(ステップワゴン)"),
			},
		},
		RepoReturnTask: structure.Todo{
			ID:       1,
			Task:     "タイヤ交換(ステップワゴン)",
			Priority: "high",
			Status:   "done",
			UserName: "rainbow777",
		},
		ExpectedTask: structure.Todo{
			ID:       1,
			Task:     "タイヤ交換(ステップワゴン)",
			Priority: "high",
			Status:   "done",
			UserName: "rainbow777",
		},
	},
	{
		TestName: "case3_Priority_Update",
		UpdateData: structure.UpdateData{
			TaskID:       1,
			AuthUserName: "rainbow777",
			UpdateRequest: structure.UpdateTaskRequest{
				Priority: makePointer("medium"),
			},
		},
		RepoReturnTask: structure.Todo{
			ID:       1,
			Task:     "タイヤ交換(ステップワゴン)",
			Priority: "medium",
			Status:   "done",
			UserName: "rainbow777",
		},
		ExpectedTask: structure.Todo{
			ID:       1,
			Task:     "タイヤ交換(ステップワゴン)",
			Priority: "medium",
			Status:   "done",
			UserName: "rainbow777",
		},
	},

	{
		TestName: "case5_Err_Unupdate",

		UpdateData: structure.UpdateData{
			TaskID:       1,
			AuthUserName: "rainbow777",
			UpdateRequest: structure.UpdateTaskRequest{
				Task: makePointer("タイヤ交換(ノート)"),
			},
		},
		RepoReturnTask: structure.Todo{
			ID:       1,
			Task:     "タイヤ交換(ステップワゴン)",
			Priority: "medium",
			Status:   "done",
			UserName: "UserA",
		},
		ExpectedTask: structure.Todo{
			ID:       1,
			Task:     "タイヤ交換(ステップワゴン)",
			Priority: "medium",
			Status:   "done",
			UserName: "UserA",
		},
		ExpectedErr: myerrors.MyAppError{
			ErrCode: myerrors.UnUpdatedTask,
			Message: "Could not check for data updates.",
			Err:     myerrors.ErrUnUpdate,
		},
	},

	{
		TestName: "case6_Err_ColumnLess",
		UpdateData: structure.UpdateData{
			TaskID:       1,
			AuthUserName: "rainbow777",
		},
		ExpectedErr: myerrors.MyAppError{
			ErrCode: myerrors.NoUpdateColumn,
			Message: "At least one colomn required",
			Err:     errors.New("No update colomn"),
		},
	},

	{
		TestName: "case7_Err_RepoExec",
		UpdateData: structure.UpdateData{
			TaskID:       1,
			AuthUserName: "rainbow777",
			UpdateRequest: structure.UpdateTaskRequest{
				Task: makePointer("タイヤ交換(ノート)"),
			},
		},
		RepoReturnErr: &myerrors.MyAppError{
			ErrCode: myerrors.TaskUpdateFailed,
			Message: "Error occurred in tx.Exec",
			Err:     errors.New("SIMULATED: Failed to execute Exec "),
		},
		ExpectedErr: myerrors.MyAppError{
			ErrCode: myerrors.UpdateDataFailed,
			Message: "Error occurred in UpdateTaskService",
			Err: &myerrors.MyAppError{
				ErrCode: myerrors.TaskUpdateFailed,
				Message: "Error occurred in tx.Exec",
				Err:     errors.New("SIMULATED: Failed to execute Exec "),
			},
		},
	},

	{
		TestName: "case8_Err_RepoGet",
		UpdateData: structure.UpdateData{
			TaskID:       1,
			AuthUserName: "rainbow777",
			UpdateRequest: structure.UpdateTaskRequest{
				Task: makePointer("タイヤ交換(ノート)"),
			},
		},
		RepoReturnErr: &myerrors.MyAppError{
			ErrCode: myerrors.ScanFailed,
			Message: "Error occurred in row.Scan",
			Err:     errors.New("SIMULATED:  This is original err from row.Scan"),
		},
		ExpectedErr: myerrors.MyAppError{
			ErrCode: myerrors.UpdateDataFailed,
			Message: "Error occurred in UpdateTaskService",
			Err: &myerrors.MyAppError{
				ErrCode: myerrors.ScanFailed,
				Message: "Error occurred in row.Scan",
				Err:     errors.New("SIMULATED:  This is original err from row.Scan"),
			},
		},
	},

	{
		TestName: "case9_ALL_Update",
		UpdateData: structure.UpdateData{
			TaskID:       1,
			AuthUserName: "rainbow777",
			UpdateRequest: structure.UpdateTaskRequest{
				Task:     makePointer("タイヤ空気圧点検"),
				Priority: makePointer("low"),
				Status:   makePointer("not_done"),
			},
		},
		RepoReturnTask: structure.Todo{
			ID:       1,
			Task:     "タイヤ空気圧点検",
			Priority: "low",
			Status:   "not_done",
			UserName: "rainbow777",
		},
		ExpectedTask: structure.Todo{
			ID:       1,
			Task:     "タイヤ空気圧点検",
			Priority: "low",
			Status:   "not_done",
			UserName: "rainbow777",
		},
	},

	{
		TestName: "case10_Error_InvalidPriority",
		UpdateData: structure.UpdateData{
			TaskID:       1,
			AuthUserName: "rainbow777",
			UpdateRequest: structure.UpdateTaskRequest{
				Priority: makePointer("midium"),
			},
		},
		ExpectedErr: myerrors.MyAppError{
			ErrCode: myerrors.BadRequest,
			Message: "Priority require high or medium or low not midium",
			Err:     errors.New("invalid priority"),
		},
	},
}
package testdata

import (
	"errors"

	"github.com/rainbow777/todolist/myerrors"
	"github.com/rainbow777/todolist/structure"
)

type GetListTestData struct {
	TestName      string
	Request       structure.GetListRequest
	ExpectedTask  []structure.Todo
	RepoReturnErr error // レポジトリ層から返されるエラーケースを格納
	ExpectedErr   myerrors.MyAppError
}

var GetListTestCases = []GetListTestData{
	{
		TestName: "case1_high_SUCCESS",
		Request: structure.GetListRequest{
			AuthUserName: "rainbow777",
			Priorities:   []string{"high"},
		},
		ExpectedTask: []structure.Todo{
			{
				ID:       1,
				Task:     "タイヤ交換",
				Priority: "high",
				Status:   "not_done",
				UserName: "rainbow777",
			},
			{
				ID:       3,
				Task:     "年金納付",
				Priority: "high",
				Status:   "not_done",
				UserName: "rainbow777",
			},
		},
	},
	{
		TestName: "case2_medium_SUCCESS",
		Request: structure.GetListRequest{
			AuthUserName: "rainbow777",
			Priorities:   []string{"medium"},
			Offset:       0,
			Limit:        20,
		},
		ExpectedTask: []structure.Todo{
			{
				ID:       2,
				Task:     "食器洗い",
				Priority: "medium",
				Status:   "not_done",
				UserName: "rainbow777",
			},
		},
	},
	{
		TestName: "case3_low_NADATA",
		Request: structure.GetListRequest{
			AuthUserName: "rainbow777",
			Priorities:   []string{"low"},
			Offset:       0,
			Limit:        20,
		},
		ExpectedTask: []structure.Todo{},
		ExpectedErr: myerrors.MyAppError{
			ErrCode: myerrors.NAData,
			Message: "no data",
			Err:     myerrors.ErrNoData,
		},
	},

	{
		TestName: "case4_FULL_SUCCESS",
		Request: structure.GetListRequest{
			AuthUserName: "rainbow777",
			Status:       "all",
			Offset:       0,
			Limit:        20,
		},
		ExpectedTask: []structure.Todo{
			{
				ID:       1,
				Task:     "タイヤ交換",
				Priority: "high",
				Status:   "not_done",
				UserName: "rainbow777",
			},
			{
				ID:       2,
				Task:     "食器洗い",
				Priority: "medium",
				Status:   "not_done",
				UserName: "rainbow777",
			},
			{
				ID:       3,
				Task:     "年金納付",
				Priority: "high",
				Status:   "not_done",
				UserName: "rainbow777",
			},
		},
	},

	{
		TestName: "case5_ERROR_GETROWS",
		Request: structure.GetListRequest{
			AuthUserName: "rainbow777",
			Priorities:   []string{"low"},
		},
		RepoReturnErr: &myerrors.MyAppError{
			ErrCode: myerrors.GetListfailed,
			Message: "Error occured in db.Query in GetRows func",
			Err:     errors.New("SIMULATED: Database Query failed due to closed connection"),
		},
		ExpectedErr: myerrors.MyAppError{
			ErrCode: myerrors.GetDataFailed,
			Message: "Error occured in GetTodoListDB",
			Err: &myerrors.MyAppError{
				ErrCode: myerrors.GetListfailed,
				Message: "Error occured in db.Query in GetRows func",
				Err:     errors.New("SIMULATED: Database Query failed due to closed connection"),
			},
		},
	},

	{
		TestName: "case6_ERROR_SCANROWS",
		Request: structure.GetListRequest{
			AuthUserName: "rainbow777",
			Priorities:   []string{"low"},
		},
		RepoReturnErr: &myerrors.MyAppError{
			ErrCode: myerrors.GetListfailed,
			Message: "Error occuerred in ScanRows in helper.go",
			Err:     errors.New("SIMULATED: Failed to scan rows"),
		},
		ExpectedErr: myerrors.MyAppError{
			ErrCode: myerrors.GetDataFailed,
			Message: "Error occured in GetTodoListDB",
			Err: &myerrors.MyAppError{
				ErrCode: myerrors.GetListfailed,
				Message: "Error occuerred in ScanRows in helper.go",
				Err:     errors.New("SIMULATED: Failed to scan rows"),
			},
		},
	},
}
package testdata

import (
	"errors"

	"github.com/rainbow777/todolist/myerrors"
)

type DeleteTaskTestData struct {
	TestName      string
	TaskID        int
	AuthUserName  string
	RepoReturnErr error
	ExpectedErr   myerrors.MyAppError
}

var DleteTaskTestCases = []DeleteTaskTestData{
	{
		TestName: "case1_Succusses",

		TaskID:       1,
		AuthUserName: "rainbow777",
	},
	{
		TestName:     "case2_Err_DeleteTask",
		TaskID:       2,
		AuthUserName: "rainbow777",
		RepoReturnErr: &myerrors.MyAppError{
			ErrCode: myerrors.TaskDeleteFailed,
			Message: "Failed to delete task",
			Err:     errors.New("SIMULATED: Here is Orizinal Err from db.Exec"),
		},
		ExpectedErr: myerrors.MyAppError{
			ErrCode: myerrors.DeleteDataFailed,
			Message: "Error occurred in DeleteTaskDB",
			Err: &myerrors.MyAppError{
				ErrCode: myerrors.TaskDeleteFailed,
				Message: "Failed to delete task",
				Err:     errors.New("SIMULATED: Here is Orizinal Err from db.Exec"),
			},
		},
	},
	{
		TestName:     "case3_Err_RowAffected",
		TaskID:       3,
		AuthUserName: "rainbow777",
		RepoReturnErr: &myerrors.MyAppError{
			ErrCode: myerrors.NoRowsAffected,
			Message: "Could not confirm database changes were complete",
			Err:     errors.New("SIMULATED: Here is Orizinal Err from result.RowsAffected"),
		},
		ExpectedErr: myerrors.MyAppError{
			ErrCode: myerrors.DeleteDataFailed,
			Message: "Error occurred in DeleteTaskDB",
			Err: &myerrors.MyAppError{
				ErrCode: myerrors.NoRowsAffected,
				Message: "Could not confirm database changes were complete",
				Err:     errors.New("SIMULATED: Here is Orizinal Err from result.RowsAffected"),
			},
		},
	},
	{
		TestName:     "case4_DBNotChange",
		TaskID:       3,
		AuthUserName: "rainbow777",
		RepoReturnErr: &myerrors.MyAppError{
			ErrCode: myerrors.UnChangeRows,
			Message: "Database has not changed",
			Err:     errors.New("No affectedRows"),
		},
		ExpectedErr: myerrors.MyAppError{
			ErrCode: myerrors.DeleteDataFailed,
			Message: "Error occurred in DeleteTaskDB",
			Err: &myerrors.MyAppError{
				ErrCode: myerrors.UnChangeRows,
				Message: "Database has not changed",
				Err:     errors.New("No affectedRows"),
			},
		},
	},
}
package testdata

import (
	"github.com/rainbow777/todolist/myerrors"
	"github.com/rainbow777/todolist/structure"
)

type InsertTaskServiceData struct {
	TestName     string
	InsertTask   structure.InsertData
	ExpectedTask structure.Todo
	ExpectedErr  myerrors.MyAppError
}

var InsertTaskTestCases = []InsertTaskServiceData{

	{
		TestName: "case1",
		InsertTask: structure.InsertData{
			Task:         "test1",
			Priority:     "high",
			Status:       "not_done",
			AuthUserName: "rainbow777",
		},
		ExpectedTask: structure.Todo{
			ID:       1,
			Task:     "test1",
			Priority: "high",
			Status:   "not_done",
			UserName: "rainbow777",
		},
	},
	{
		TestName: "case2",
		InsertTask: structure.InsertData{
			Task:         "test2",
			Priority:     "medium",
			Status:       "not_done",
			AuthUserName: "rainbow777",
		},
		ExpectedTask: structure.Todo{
			ID:       2,
			Task:     "test2",
			Priority: "medium",
			Status:   "not_done",
			UserName: "rainbow777",
		},
	},
	{
		TestName: "case3",
		InsertTask: structure.InsertData{
			Task:         "入金の確認",
			Priority:     "very high",
			Status:       "not_done",
			AuthUserName: "rainbow777",
		},
		ExpectedErr: myerrors.MyAppError{
			ErrCode: myerrors.BadRequest,
			Message: "Please specify a valid priority",
		},
	},

	{
		TestName: "case4",
		InsertTask: structure.InsertData{
			Task:         "",
			Priority:     "high",
			Status:       "not_done",
			AuthUserName: "rainbow777",
		},
		ExpectedErr: myerrors.MyAppError{
			ErrCode: myerrors.BadRequest,
			Message: "Please enter the task content",
		},
	},
}
package services_test

import (
	"testing"

	"github.com/rainbow777/todolist/services"
	"github.com/rainbow777/todolist/services/testdata"
)

func TestInsertTaskService(t *testing.T) {

	for _, test := range testdata.InsertTaskTestCases {
		t.Run(test.TestName, func(t *testing.T) {
			repo := MakeRepoMockInsert(test)

			ser := services.NewMyAppService(repo)

			returnTask, err := ser.InsertTaskService(test.InsertTask)

			CheckReturnedDataInsertTask(t, test, returnTask, err)
		})
	}

}

func TestGetTaskService(t *testing.T) {

	for _, test := range testdata.GetTaskTestCases {
		t.Run(test.TestName, func(t *testing.T) {
			repoMock := MakeRepoMockGetTask(test)

			ser := services.NewMyAppService(repoMock)
			returnedTask, err := ser.GetTaskService(test.RequestID, test.UserName)

			CheckReturnedDataGetTask(t, test, returnedTask, err)
		})
	}
}

func TestGetListService(t *testing.T) {

	for _, test := range testdata.GetListTestCases {
		t.Run(test.TestName, func(t *testing.T) {

			repoMock := MakeRepoMockGetList(test)
			ser := services.NewMyAppService(repoMock)

			returnedList, err := ser.GetListService(test.Request)

			CheckReturnedDataGetList(t, test, returnedList, err)

		})
	}
}

func TestUpdateTaskService(t *testing.T) {

	for _, test := range testdata.UpdateTaskTestCases {
		t.Run(test.TestName, func(t *testing.T) {

			repoMock := MakeRepoMockUpdate(test)
			ser := services.NewMyAppService(repoMock)

			returnedData, err := ser.UpdateTaskService(&test.UpdateData)

			CheckReturnedDataUpdate(t, test, returnedData, err)
		})
	}
}

func TestDeleteTaskService(t *testing.T) {

	for _, test := range testdata.DleteTaskTestCases {
		t.Run(test.TestName, func(t *testing.T) {
			repoMock := MakeRepoMockDelete(test)
			ser := services.NewMyAppService(repoMock)

			err := ser.DeleteTaskService(test.TaskID, test.AuthUserName)

			CheckReturnedDataDelete(t, test, err)
		})
	}
}
package myerrors

import (
	"encoding/json"
	"errors"
	"log"
	"net/http"
)

func ErrorHandler(w http.ResponseWriter, err error) {
	var myErr *MyAppError
	// 第三引数で受け取ったerror型のerrを自作エラー型に変換する
	if !errors.As(err, &myErr) {
		myErr = &MyAppError{
			ErrCode: Unknown,
			Message: "internal process failed　事前に想定していないエラーが発生しました",
			Err:     err,
		}
	}

	// 開発者向けに詳細なエラーログを出力
	log.Printf("Final error response: MyErrCode=%s Message=%s OriginalErr=%v",
		myErr.ErrCode, myErr.Message, myErr.Err)

	// ユーザーに返すステータスコードの変数を用意
	var statusCode int

	// エラーコード別に該当ステータスコードを格納
	switch myErr.ErrCode {
	case NAData:
		statusCode = http.StatusNotFound
	case BadRequest, BadPath, BadQuery:
		statusCode = http.StatusBadRequest
	case RequiredAuthorizationHeader, CannotMakeValidator, Unauthorizated:
		statusCode = http.StatusUnauthorized
	case NotMatchUserName:
		statusCode = http.StatusForbidden
	default:
		statusCode = http.StatusInternalServerError
	}

	// ステータスコードをレスポンスのヘッダに格納
	w.WriteHeader(statusCode)

	// ユーザーにエラー内容を送信
	err = json.NewEncoder(w).Encode(myErr)
	if err != nil {
		log.Printf("Fatal: Failed to encode JSON response: %v", err)
	}
}
package myerrors

import "fmt"

type MyAppError struct {
	ErrCode
	Message string
	Err     error `json:"-"`
}

func (myErr *MyAppError) Error() string {
	if myErr == nil {
		return "nil MyAppError"
	}

	output := fmt.Sprintf("[%s] %s", myErr.ErrCode, myErr.Message)

	if myErr.Err != nil {
		output = fmt.Sprintf("%s: %s", output, myErr.Err.Error())
	}

	return output
}

func (myErr *MyAppError) Unwrap() error {
	return myErr.Err
}

func (code ErrCode) Wrap(err error, message string) error {
	return &MyAppError{ErrCode: code, Message: message, Err: err}
}
package myerrors

type ErrCode string

const (
	Unknown ErrCode = "U000"

	InsertFailed     ErrCode = "R001"
	NoRowsAffected   ErrCode = "R002"
	GetTaskFailed    ErrCode = "R003"
	ScanFailed       ErrCode = "R004"
	GetListfailed    ErrCode = "R005"
	BadColumn        ErrCode = "R006"
	TaskUpdateFailed ErrCode = "R007"
	TaskDeleteFailed ErrCode = "R008"
	UnChangeRows     ErrCode = "R009"
	NotFound         ErrCode = "R010"

	InsertDataFailed ErrCode = "S001"
	GetDataFailed    ErrCode = "S002"
	NAData           ErrCode = "S003"
	UpdateDataFailed ErrCode = "S004"
	DeleteDataFailed ErrCode = "S005"
	BadRequest       ErrCode = "S006"
	UnUpdatedTask    ErrCode = "S007"
	NoUpdateColumn   ErrCode = "S008"

	ReqBodyDecodeFailed  ErrCode = "C001"
	BadPath              ErrCode = "C002"
	BadQuery             ErrCode = "C003"
	ResponseEncodeFailed ErrCode = "C004"

	RequiredAuthorizationHeader ErrCode = "A001"
	CannotMakeValidator         ErrCode = "A002"
	Unauthorizated              ErrCode = "A003"
	NotMatchUserName            ErrCode = "A004"
	FailedValidate              ErrCode = "A005"
	FailedLoadEnv               ErrCode = "A006"
)
package myerrors

import "errors"

var ErrNoData = errors.New("get 0 record from db.Query")
var ErrRequest = errors.New("invalid request")
var ErrQuery = errors.New("invalid query parameter")
var AffectedNoRows = errors.New("no rows affected")
var ErrColumn = errors.New("invalid column")
var ErrAuthUser = errors.New("Usernames do not match")
var ErrUnUpdate = errors.New("Task is unupdated")
package controllers_test

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/gorilla/mux"
	"github.com/rainbow777/todolist/api/middlewares"
	"github.com/rainbow777/todolist/controllers"
	"github.com/rainbow777/todolist/controllers/testdata"
)

func TestInsertTaskHandler(t *testing.T) {
	for _, test := range testdata.InsertTaskTestCases {
		t.Run(test.Name, func(t *testing.T) {

			con := GetMockInInsertCon(&test)

			jsonBody, err := json.Marshal(test.InsertTask)
			if err != nil {
				t.Fatalf("Failed to encode a testdata to JSON %v", err)
			}

			// ハンドラに渡すリクエストを自作
			req := httptest.NewRequest(http.MethodPost, "/todo/insert", bytes.NewBuffer(jsonBody))
			req.Header.Set("Content-Type", "application/json")

			req = middlewares.SetUserName(req, "rainbow777")

			// テスト用レスポンスを生成
			w := httptest.NewRecorder()

			router := mux.NewRouter()
			router.HandleFunc("/todo/insert", con.InsertTaskHandler).Methods(http.MethodPost)
			router.ServeHTTP(w, req)

			CheckResponseInsertedData(w, t, &test)
		})
	}
}

func TestGetTaskHandler(t *testing.T) {
	for _, test := range testdata.GetTaskTestCases {
		t.Run(test.Name, func(t *testing.T) {

			con := GetMockInTaskCon(&test)

			// ハンドラに渡すリクエストを自作
			url := fmt.Sprintf("http://localhost:8080/todo/gettask/%s", test.ID)
			req := httptest.NewRequest(http.MethodGet, url, nil)
			req.Header.Set("Content-Type", "application/json")

			req = middlewares.SetUserName(req, "rainbow777")

			w := httptest.NewRecorder()

			router := mux.NewRouter()
			// ハンドラのテストをしたいので正規表現を削除
			router.HandleFunc("/todo/gettask/{id}", con.GetTaskHandler).Methods(http.MethodGet)
			router.ServeHTTP(w, req)

			CheckResponseTask(w, t, &test)
		})
	}
}

func TestGetListHandler(t *testing.T) {
	for _, test := range testdata.GetListTestCases {
		t.Run(test.Name, func(t *testing.T) {

			con := GetMockInListCon(&test)

			url := fmt.Sprintf("http://localhost:8080/todo/getlist%s", test.QueryParam)
			req := httptest.NewRequest(http.MethodGet, url, nil)
			req.Header.Set("Content-Type", "application/json")

			req = middlewares.SetUserName(req, "rainbow777")

			w := httptest.NewRecorder()

			router := mux.NewRouter()
			router.HandleFunc("/todo/getlist", con.GetListHandler).Methods(http.MethodGet)
			router.ServeHTTP(w, req)

			CheckResponseList(w, t, &test)
		})
	}
}

func TestUpdateTaskHandler(t *testing.T) {
	for _, test := range testdata.UpdateTaskTestCases {
		t.Run(test.Name, func(t *testing.T) {

			con := GetMockInUpdateCon(&test)

			jsonBody, err := json.Marshal(test.UpdateRequest)
			if err != nil {
				t.Fatalf("Failed to encode a testdata to JSON %v", err)
			}

			// ハンドラに渡すリクエストを自作
			url := fmt.Sprintf("/todo/update/%d", test.TaskID)
			req := httptest.NewRequest(http.MethodPatch, url, bytes.NewBuffer(jsonBody))
			req.Header.Set("Content-Type", "application/json")
			req = middlewares.SetUserName(req, "rainbow777")

			w := httptest.NewRecorder()

			router := mux.NewRouter()
			router.HandleFunc("/todo/update/{id}", con.UpdateTaskHandler).Methods(http.MethodPatch)
			router.ServeHTTP(w, req)

			CheckResponseUpdateTask(w, t, &test)
		})
	}
}

func TestDeleteTaskHandler(t *testing.T) {
	for _, test := range testdata.DeleteTestCases {
		t.Run(test.Name, func(t *testing.T) {

			req := httptest.NewRequest(http.MethodDelete, test.URL, nil)
			req.Header.Set("Content-Type", "application/json")
			req = middlewares.SetUserName(req, "rainbow777")

			w := httptest.NewRecorder()

			mockService := testdata.NewServiceMock()
			con := controllers.NewMyAppController(mockService)

			router := mux.NewRouter()
			router.HandleFunc("/todo/delete/{id}", con.DeleteTaskHandler).Methods(http.MethodDelete)
			router.ServeHTTP(w, req)

			CheckResponseDeleteHandler(w, t, &test)
		})
	}
}
package controllers_test

import (
	"os"
	"testing"
)

func TestMain(m *testing.M) {

	os.Exit(m.Run())
}
package controllers

import (
	"net/http"
	"strconv"

	"github.com/rainbow777/todolist/myerrors"
	"github.com/rainbow777/todolist/structure"
)

// クエリパラメータの内容を確認する関数
func CheckQueryParam(req *http.Request) (*structure.GetListRequest, error) {
	getListRequest := structure.GetListRequest{
		Status: "not_done",
		Offset: 0,
		Limit:  20,
	}

	reqQuery := req.URL.Query()

	if len(reqQuery) == 0 {
		return &getListRequest, nil
	}

	// クエリ名の適正値リストの定義
	allowedQueries := map[string]bool{"priority": true, "status": true, "page": true}

	// クエリ名の検証
	for query := range reqQuery {
		if !allowedQueries[query] {
			return nil, myerrors.BadQuery.Wrap(myerrors.ErrQuery, "Query name must be priority or status or page")
		}
	}

	if reqQuery["priority"] != nil {
		getListRequest.Priorities = reqQuery["priority"]
		for _, priority := range getListRequest.Priorities {
			if priority != "high" && priority != "medium" && priority != "low" {
				return nil, myerrors.BadQuery.Wrap(myerrors.ErrQuery,
					"priority requier high or medium or low")
			}
		}
	}

	if statusSlice := reqQuery["status"]; len(statusSlice) > 1 {
		return nil, myerrors.BadQuery.Wrap(myerrors.ErrQuery, "Status must be only one parameter")
	}

	allowedStatus := map[string]bool{"done": true, "all": true, "All": true, "not_done": true}

	for _, status := range reqQuery["status"] {
		if !allowedStatus[status] {
			return nil, myerrors.BadQuery.Wrap(myerrors.ErrQuery, "Status must be all, done, not_done")
		}
		getListRequest.Status = status
	}

	page := 1
	if reqQuery["page"] != nil {
		var err error
		pageSLise := reqQuery["page"]
		if len(pageSLise) == 1 {
			page, err = strconv.Atoi(pageSLise[0])
			if err != nil {
				return nil, myerrors.BadQuery.Wrap(myerrors.ErrQuery,
					"page must be a valid number")
			}
		} else if len(pageSLise) > 1 {
			return nil, myerrors.BadQuery.Wrap(myerrors.ErrQuery,
				"Only one page can be specified at a time")
		}

		if page < 1 {
			return nil, myerrors.BadQuery.Wrap(myerrors.ErrQuery,
				"Page number must be 1 or more")
		}

		if page > 1000 {
			return nil, myerrors.BadQuery.Wrap(myerrors.ErrQuery,
				"You can specify a maximum of 1000 pages")
		}

	}

	getListRequest.Offset = (page - 1) * getListRequest.Limit

	return &getListRequest, nil
}
package controllers_test

import (
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/rainbow777/todolist/controllers"
	"github.com/rainbow777/todolist/controllers/testdata"
	"github.com/rainbow777/todolist/myerrors"
	"github.com/rainbow777/todolist/structure"
	"github.com/stretchr/testify/assert"
)

func GetMockInInsertCon(test *testdata.InsertedTaskTestData) *controllers.MyAppController {

	mockService := testdata.NewServiceMock()
	mockService.InsertTaskServiceFunc = func(insertData structure.InsertData) (structure.Todo, error) {
		if test.ExpectedError.ErrCode != "" {
			return structure.Todo{}, &test.ExpectedError
		}
		return test.ExpectedTask, nil
	}

	return controllers.NewMyAppController(mockService)
}

func CheckResponseInsertedData(w *httptest.ResponseRecorder, t *testing.T, test *testdata.InsertedTaskTestData) {

	assert.Equal(t, test.Code, w.Code, "Status Code mismatch")
	responseBody := w.Body.Bytes()
	if w.Code == http.StatusOK {

		var returnedTask structure.Todo
		err := json.Unmarshal(responseBody, &returnedTask)
		if err != nil {
			t.Fatalf("Failed to unmarshal responseBody %v", err)
		}

		assert.Equal(t, test.ExpectedTask.ID, returnedTask.ID, "Task ID mismatch")
		assert.Equal(t, test.ExpectedTask.Task, returnedTask.Task, "Task content mismatch")
		assert.Equal(t, test.ExpectedTask.Priority, returnedTask.Priority, "Priority mismatch")
		assert.Equal(t, test.ExpectedTask.Status, returnedTask.Status, "Status mismatch")
		assert.Equal(t, test.ExpectedTask.UserName, returnedTask.UserName, "UserName mismatch")

	} else {

		var returnedError myerrors.MyAppError
		err := json.Unmarshal(responseBody, &returnedError)
		if err != nil {
			t.Fatalf("Failed to unmarshal responseBody %v", err)
		}

		assert.Equal(t, test.ExpectedError.ErrCode, returnedError.ErrCode, "ErrCode mismatch")
		assert.Equal(t, test.ExpectedError.Message, returnedError.Message, "Message mismatch")
	}

}

func GetMockInTaskCon(test *testdata.GetTaskTestData) *controllers.MyAppController {

	mockService := testdata.NewServiceMock()
	mockService.GetTaskServiceFunc = func(id int, username string) (structure.Todo, error) {
		if test.ExpectedError.ErrCode != "" {
			return structure.Todo{}, &test.ExpectedError
		}
		return test.ExpectedTask, nil
	}

	return controllers.NewMyAppController(mockService)
}

func CheckResponseTask(w *httptest.ResponseRecorder, t *testing.T, test *testdata.GetTaskTestData) {
	assert.Equal(t, test.Code, w.Code, "Status Code mismatch")

	responseBody := w.Body.Bytes()

	if w.Code == http.StatusOK {

		var returnedTask structure.Todo
		err := json.Unmarshal(responseBody, &returnedTask)
		if err != nil {
			t.Fatalf("Failed to unmarshal responseBody %v", err)
		}

		assert.Equal(t, test.ExpectedTask.ID, returnedTask.ID, "Task ID mismatch")
		assert.Equal(t, test.ExpectedTask.Task, returnedTask.Task, "Task content mismatch")
		assert.Equal(t, test.ExpectedTask.Priority, returnedTask.Priority, "Priority mismatch")
		assert.Equal(t, test.ExpectedTask.Status, returnedTask.Status, "Status mismatch")
		assert.Equal(t, test.ExpectedTask.UserName, returnedTask.UserName, "UserName mismatch")

	} else {

		var returnedError myerrors.MyAppError
		err := json.Unmarshal(responseBody, &returnedError)
		if err != nil {
			t.Fatalf("Failed to unmarshal responseBody %v", err)
		}

		assert.Equal(t, test.ExpectedError.ErrCode, returnedError.ErrCode, "ErrCode mismatch")
		assert.Equal(t, test.ExpectedError.Message, returnedError.Message, "Message mismatch")
	}

}

func GetMockInListCon(test *testdata.GetListTestData) *controllers.MyAppController {
	mockService := testdata.NewServiceMock()
	mockService.GetListServiceFunc = func(getListRequest structure.GetListRequest) ([]structure.Todo, error) {
		if test.ExpectedError.ErrCode != "" {
			return []structure.Todo{}, &test.ExpectedError

		}
		return test.ExpectedList, nil
	}

	return controllers.NewMyAppController(mockService)
}

func CheckResponseList(w *httptest.ResponseRecorder, t *testing.T, test *testdata.GetListTestData) {
	assert.Equal(t, test.Code, w.Code, "Status Code mismatch")

	responseBody := w.Body.Bytes()

	if w.Code == http.StatusOK {

		var returnedList []structure.Todo
		err := json.Unmarshal(responseBody, &returnedList)
		if err != nil {
			t.Fatalf("Failed to unmarshal responseBody %v", err)
		}
		for i, returnedTask := range returnedList {
			assert.Equal(t, test.ExpectedList[i].ID, returnedTask.ID, "Task ID mismatch")
			assert.Equal(t, test.ExpectedList[i].Task, returnedTask.Task, "Task content mismatch")
			assert.Equal(t, test.ExpectedList[i].Priority, returnedTask.Priority, "Priority mismatch")
			assert.Equal(t, test.ExpectedList[i].Status, returnedTask.Status, "Status mismatch")
			assert.Equal(t, test.ExpectedList[i].UserName, returnedTask.UserName, "UserName mismatch")
		}

	} else {

		var returnedError myerrors.MyAppError
		err := json.Unmarshal(responseBody, &returnedError)
		if err != nil {
			t.Fatalf("Failed to unmarshal responseBody %v", err)
		}

		assert.Equal(t, test.ExpectedError.ErrCode, returnedError.ErrCode, "ErrCode mismatch")
		assert.Equal(t, test.ExpectedError.Message, returnedError.Message, "Message mismatch")
	}

}

func CheckResponseUpdateTask(w *httptest.ResponseRecorder, t *testing.T, test *testdata.UpdateTaskData) {
	assert.Equal(t, test.Code, w.Code, "Status Code mismatch")

	responseBody := w.Body.Bytes()

	if w.Code == http.StatusOK {
		var actualBody structure.Todo
		err := json.Unmarshal(responseBody, &actualBody)
		if err != nil {
			t.Fatalf("Failed to Unmarshal actual body%v", err)
		}
		assert.Equal(t, test.ReturnValue.ID, actualBody.ID, "TaskID mismatch")
		assert.Equal(t, test.ReturnValue.Task, actualBody.Task, "Task content mismatch")
		assert.Equal(t, test.ReturnValue.Priority, actualBody.Priority, "Priority mismatch")
		assert.Equal(t, test.ReturnValue.Status, actualBody.Status, "Status mismatch")
		assert.Equal(t, test.ReturnValue.UserName, actualBody.UserName, "UserName mismatch")
	} else {
		var actualError myerrors.MyAppError
		err := json.Unmarshal(responseBody, &actualError)
		if err != nil {
			t.Fatalf("Failed to Unmarshal actual body%v", err)
		}
		assert.Equal(t, test.ExpectedError.ErrCode, actualError.ErrCode, "ErrCode mismatch")
		assert.Equal(t, test.ExpectedError.Message, actualError.Message, "Message mismathc")
	}
}

func GetMockInUpdateCon(test *testdata.UpdateTaskData) *controllers.MyAppController {
	mockService := testdata.NewServiceMock()
	mockService.UpdateTaskServiceFunc = func(updateData *structure.UpdateData) (structure.Todo, error) {
		if test.ExpectedError.ErrCode != "" {
			return structure.Todo{}, &test.ExpectedError
		}
		return test.ReturnValue, nil
	}

	return controllers.NewMyAppController(mockService)
}

func CheckResponseDeleteHandler(w *httptest.ResponseRecorder, t *testing.T, test *testdata.DeleteTestData) {

	assert.Equal(t, test.Code, w.Code, "StatusCode is unmatched")

	if w.Code == http.StatusOK {
		responseBody := w.Body.Bytes()
		var responseMessage string
		err := json.Unmarshal(responseBody, &responseMessage)
		if err != nil {
			t.Fatalf("Failed to Unmarshal responseBody %v", err)
		}
		assert.Equal(t, test.ExpectedRes, responseMessage, "Response Massage is unmatched")
	} else {
		responseBody := w.Body.Bytes()
		var responseErr myerrors.MyAppError
		err := json.Unmarshal(responseBody, &responseErr)
		if err != nil {
			t.Fatalf("Failed to Unmarshal responseBody %v", err)
		}
		assert.Equal(t, test.ExpectedRes, responseErr.Message, "Err Massage is unmatched")
	}

}
package controllers

import (
	"encoding/json"
	"log"
	"net/http"
	"strconv"

	"github.com/gorilla/mux"
	"github.com/rainbow777/todolist/api/middlewares"
	"github.com/rainbow777/todolist/myerrors"
	"github.com/rainbow777/todolist/services"
	"github.com/rainbow777/todolist/structure"
)

type MyAppController struct {
	Service services.ServiceInterFace
}

func NewMyAppController(s services.ServiceInterFace) *MyAppController {
	return &MyAppController{Service: s}
}

// 新規タスクをTodoListに追加するメソッド
func (c MyAppController) InsertTaskHandler(w http.ResponseWriter, r *http.Request) {

	var insertData structure.InsertData
	err := json.NewDecoder(r.Body).Decode(&insertData)
	if err != nil {
		err = myerrors.ReqBodyDecodeFailed.Wrap(err, "Failed to decode r.Body")
		myerrors.ErrorHandler(w, err)
		return
	}
	insertData.AuthUserName = middlewares.GetUserName(r.Context())

	// 新規タスクの追加をサービス層に依頼
	addedtask, err := c.Service.InsertTaskService(insertData)
	if err != nil {
		myerrors.ErrorHandler(w, err)
		return
	}

	// レスポンス処理
	w.WriteHeader(http.StatusOK)
	err = json.NewEncoder(w).Encode(addedtask)
	if err != nil {
		log.Printf("Failed to encode JSON response: %v", err)
		return
	}
}

// 指定したIDのタスク情報をTodoListから取得するメソッド
func (c MyAppController) GetTaskHandler(w http.ResponseWriter, r *http.Request) {
	// クエリパラメータからIDを取得
	taskID, err := strconv.Atoi(mux.Vars(r)["id"])
	if err != nil {
		err = myerrors.BadPath.Wrap(err, "invalid path parameter")
		myerrors.ErrorHandler(w, err)
		return
	}

	authUserName := middlewares.GetUserName(r.Context())

	// 対象IDのタスク情報の取得をサービス層に依頼
	task, err := c.Service.GetTaskService(taskID, authUserName)
	if err != nil {
		myerrors.ErrorHandler(w, err)
		return
	}
	// レスポンス処理
	err = json.NewEncoder(w).Encode(task)
	if err != nil {
		log.Printf("Failed to encode JSON response: %v", err)
		return
	}
}

// TodoListを取得するメソッド
func (c MyAppController) GetListHandler(w http.ResponseWriter, r *http.Request) {
	// クエリパラメータにpriorityが指定されているかを確認
	getListRequest, err := CheckQueryParam(r)
	if err != nil {
		myerrors.ErrorHandler(w, err)
		return
	}

	getListRequest.AuthUserName = middlewares.GetUserName(r.Context())

	// テータベースからTodoListを取得する処理をサービス層に依頼
	// priorityが空の場合、list内の全タスクが戻ってくる
	todolist, err := c.Service.GetListService(*getListRequest)
	if err != nil {
		myerrors.ErrorHandler(w, err)
		return
	}

	// レスポンス処理
	err = json.NewEncoder(w).Encode(todolist)
	if err != nil {
		log.Printf("Failed to encode JSON response: %v", err)
		return
	}
}

// TodoList内のタスク情報を更新するメソッド
func (c MyAppController) UpdateTaskHandler(w http.ResponseWriter, r *http.Request) {
	var updateData structure.UpdateData
	var err error
	updateData.TaskID, err = strconv.Atoi(mux.Vars(r)["id"])
	if err != nil {
		err = myerrors.BadPath.Wrap(err, "TaskID is requred in path parameter")
		myerrors.ErrorHandler(w, err)
		return
	}
	updateData.AuthUserName = middlewares.GetUserName(r.Context())

	// var updateValues structure.Todo
	err = json.NewDecoder(r.Body).Decode(&updateData.UpdateRequest)
	if err != nil {
		err = myerrors.ReqBodyDecodeFailed.Wrap(err, "Your request failed to be loaded.")
		myerrors.ErrorHandler(w, err)
		return
	}

	// データベースの更新処理をサービス層に依頼
	updatedTask, err := c.Service.UpdateTaskService(&updateData)
	if err != nil {
		myerrors.ErrorHandler(w, err)
		return
	}

	// リスポンス処理
	err = json.NewEncoder(w).Encode(updatedTask)
	if err != nil {
		log.Printf("Failed to encode JSON response: %v", err)
		return
	}
}

// TodoList内のタスクを削除するメソッド
func (c MyAppController) DeleteTaskHandler(w http.ResponseWriter, r *http.Request) {

	taskID, err := strconv.Atoi(mux.Vars(r)["id"])
	if err != nil {
		err = myerrors.BadPath.Wrap(err, "TaskID is requred in path parameter")
		myerrors.ErrorHandler(w, err)
		return
	}

	username := middlewares.GetUserName(r.Context())

	// データベース内のタスク削除をサービス層に依頼
	err = c.Service.DeleteTaskService(taskID, username)
	if err != nil {
		myerrors.ErrorHandler(w, err)
		return
	}

	// リスポンス処理
	err = json.NewEncoder(w).Encode("The specified task has been deleted.")
	if err != nil {
		log.Printf("Failed to encode JSON response: %v", err)
		return
	}
}
package testdata

import (
	"net/http"
)

type DeleteTestData struct {
	Name        string
	Code        int
	URL         string
	ExpectedRes string
}

var DeleteTestCases = []DeleteTestData{

	{
		Name:        "case1",
		Code:        http.StatusOK,
		URL:         "/todo/delete/1",
		ExpectedRes: "The specified task has been deleted.",
	},
	{
		Name:        "case2",
		Code:        http.StatusOK,
		URL:         "/todo/delete/2",
		ExpectedRes: "The specified task has been deleted.",
	},
	{
		Name:        "case3",
		Code:        http.StatusBadRequest,
		URL:         "/todo/delete/あ",
		ExpectedRes: "TaskID is requred in path parameter",
	},
}
package testdata

import (
	"errors"

	"github.com/rainbow777/todolist/structure"
)

type ServiceMock struct {
	InsertTaskServiceFunc func(structure.InsertData) (structure.Todo, error)
	GetTaskServiceFunc    func(int, string) (structure.Todo, error)
	GetListServiceFunc    func(structure.GetListRequest) ([]structure.Todo, error)
	UpdateTaskServiceFunc func(*structure.UpdateData) (structure.Todo, error)
}

func NewServiceMock() *ServiceMock {
	return &ServiceMock{}
}

func (s *ServiceMock) InsertTaskService(insertData structure.InsertData) (structure.Todo, error) {
	if s.InsertTaskServiceFunc != nil {
		return s.InsertTaskServiceFunc(insertData)
	}
	return structure.Todo{}, errors.New("InsertTaskServiceFunc isn't set up")
}

func (s *ServiceMock) GetTaskService(taskID int, username string) (structure.Todo, error) {

	if s.GetTaskServiceFunc != nil {
		return s.GetTaskServiceFunc(taskID, username)
	}

	return structure.Todo{}, errors.New("GetTaskServiceFunc isn't set up")
}

func (s *ServiceMock) GetListService(getListRequest structure.GetListRequest) ([]structure.Todo, error) {

	if s.GetListServiceFunc != nil {
		return s.GetListServiceFunc(getListRequest)
	}

	return []structure.Todo{}, errors.New("GetListServiceFunc isn't set up")
}

func (s *ServiceMock) UpdateTaskService(updateData *structure.UpdateData) (structure.Todo, error) {

	if s.UpdateTaskServiceFunc != nil {
		return s.UpdateTaskServiceFunc(updateData)
	}

	return structure.Todo{}, errors.New("UpdateTaskServiceFunc isn't set up")
}

func (s *ServiceMock) DeleteTaskService(taskID int, username string) error {
	return nil
}
package testdata

import (
	"net/http"

	"github.com/rainbow777/todolist/myerrors"
	"github.com/rainbow777/todolist/structure"
)

type UpdateTaskData struct {
	Name          string
	Code          int
	TaskID        int
	UpdateRequest structure.UpdateTaskRequest
	ReturnValue   structure.Todo
	ExpectedError myerrors.MyAppError
}

func makePointerStr(s string) *string { return &s }

var UpdateTaskTestCases = []UpdateTaskData{
	{
		Name:   "case1",
		Code:   http.StatusOK,
		TaskID: 1,
		UpdateRequest: structure.UpdateTaskRequest{
			Task: makePointerStr("Updated Task 1"),
		},
		ReturnValue: structure.Todo{
			ID:       1,
			Task:     "Updated Task 1",
			Priority: "high",
			Status:   "not_done",
			UserName: "rainbow777",
		},
	}, {
		Name:   "case2",
		Code:   http.StatusOK,
		TaskID: 1,
		UpdateRequest: structure.UpdateTaskRequest{
			Priority: makePointerStr("medium"),
		},
		ReturnValue: structure.Todo{
			ID:       1,
			Task:     "Updated Task 1",
			Priority: "medium",
			Status:   "not_done",
			UserName: "rainbow777",
		},
	}, {
		Name:   "case3",
		Code:   http.StatusOK,
		TaskID: 1,
		UpdateRequest: structure.UpdateTaskRequest{
			Priority: makePointerStr("low"),
		},
		ReturnValue: structure.Todo{
			ID:       1,
			Task:     "Updated Task 1",
			Priority: "low",
			Status:   "not_done",
			UserName: "rainbow777",
		},
	}, {
		Name:   "case4",
		Code:   http.StatusOK,
		TaskID: 1,
		UpdateRequest: structure.UpdateTaskRequest{
			Priority: makePointerStr("high"),
		},
		ReturnValue: structure.Todo{
			ID:       1,
			Task:     "Updated Task 1",
			Priority: "high",
			Status:   "not_done",
			UserName: "rainbow777",
		},
	}, {
		Name:   "case5",
		Code:   http.StatusOK,
		TaskID: 1,
		UpdateRequest: structure.UpdateTaskRequest{
			Status: makePointerStr("done"),
		}, ReturnValue: structure.Todo{
			ID:       1,
			Task:     "Updated Task 1",
			Priority: "high",
			Status:   "done",
			UserName: "rainbow777",
		},
	}, {
		Name:   "case6",
		Code:   http.StatusOK,
		TaskID: 1,
		UpdateRequest: structure.UpdateTaskRequest{
			Task: makePointerStr("Reupdated Task 1"),
		}, ReturnValue: structure.Todo{
			ID:       1,
			Task:     "Reupdated Task 1",
			Priority: "high",
			Status:   "done",
			UserName: "rainbow777",
		},
	},
	{
		Name:   "case7",
		Code:   http.StatusOK,
		TaskID: 2,
		UpdateRequest: structure.UpdateTaskRequest{
			Task: makePointerStr("Updated Task 2"),
		}, ReturnValue: structure.Todo{
			ID:       2,
			Task:     "Updated Task 2",
			Priority: "high",
			Status:   "not_done",
			UserName: "rainbow777",
		},
	},
	{
		Name:   "case8",
		Code:   http.StatusBadRequest,
		TaskID: 2,
		UpdateRequest: structure.UpdateTaskRequest{
			Priority: makePointerStr("midium"),
		},
		ExpectedError: myerrors.MyAppError{
			ErrCode: myerrors.BadRequest,
			Message: "Please enter a valid Column name",
		},
	},
	{
		Name: "case9",
		Code: http.StatusBadRequest,
		UpdateRequest: structure.UpdateTaskRequest{
			Priority: makePointerStr("medium"),
		},
		ExpectedError: myerrors.MyAppError{
			ErrCode: myerrors.BadPath,
			Message: "TaskID is requred in path parameter",
		},
	},

	{
		Name:   "case10",
		Code:   http.StatusOK,
		TaskID: 2,
		UpdateRequest: structure.UpdateTaskRequest{
			Priority: makePointerStr("medium"),
			Status:   makePointerStr("done"),
		}, ReturnValue: structure.Todo{
			ID:       2,
			Task:     "Updated Task 2",
			Priority: "medium",
			Status:   "done",
			UserName: "rainbow777",
		},
	},
}
package testdata

import (
	"net/http"

	"github.com/rainbow777/todolist/myerrors"
	"github.com/rainbow777/todolist/structure"
)

type InsertedTaskTestData struct {
	Name          string
	Code          int
	InsertTask    structure.InsertData
	ExpectedTask  structure.Todo
	ExpectedError myerrors.MyAppError
}

var InsertTaskTestCases = []InsertedTaskTestData{
	{
		Name: "case1",
		Code: http.StatusOK,

		InsertTask: structure.InsertData{
			Task: "洗濯", Priority: "medium", Status: "not_done", AuthUserName: "rainbow777",
		},

		ExpectedTask: structure.Todo{
			ID: 1, Task: "洗濯", Priority: "medium", Status: "not_done", UserName: "rainbow777",
		},
	},

	{
		Name: "case2",
		Code: http.StatusForbidden,

		InsertTask: structure.InsertData{
			Task: "面接", Priority: "high", Status: "not_done", AuthUserName: "rainbow77",
		},

		ExpectedError: myerrors.MyAppError{
			ErrCode: myerrors.NotMatchUserName, Message: "You don't have the authority to do that",
		},
	},

	{
		Name: "case3",
		Code: http.StatusOK,

		InsertTask: structure.InsertData{
			Task: "ミーティング", Priority: "high", Status: "not_done", AuthUserName: "rainbow777",
		},

		ExpectedTask: structure.Todo{
			ID: 2, Task: "ミーティング", Priority: "high", Status: "not_done", UserName: "rainbow777",
		},
	},
}
package testdata

import (
	"net/http"

	"github.com/rainbow777/todolist/myerrors"
	"github.com/rainbow777/todolist/structure"
)

// 以下　GetListHandler用テストデータ
type GetListTestData struct {
	Name          string
	QueryParam    string
	Code          int
	ExpectedList  []structure.Todo    // 成功時のみ使用
	ExpectedError myerrors.MyAppError //失敗時のみ使用
}

var GetListTestCases = []GetListTestData{
	{
		Name:       "case1_High",
		QueryParam: "?priority=high",
		Code:       http.StatusOK,
		ExpectedList: []structure.Todo{
			{
				ID:       1,
				Task:     "Test Task 1",
				Priority: "high",
				Status:   "not_done",
				UserName: "rainbow777",
			}, {
				ID:       2,
				Task:     "Test Task 2",
				Priority: "high",
				Status:   "done",
				UserName: "rainbow777",
			}, {
				ID:       3,
				Task:     "Test Task 3",
				Priority: "high",
				Status:   "not_done",
				UserName: "rainbow777",
			},
		},
	},

	{
		Name:       "case2_Medium",
		QueryParam: "?priority=medium",
		Code:       http.StatusOK,
		ExpectedList: []structure.Todo{
			{
				ID:       4,
				Task:     "Test Task 4",
				Priority: "medium",
				Status:   "not_done",
				UserName: "rainbow777",
			}, {
				ID:       5,
				Task:     "Test Task 5",
				Priority: "medium",
				Status:   "done",
				UserName: "rainbow777",
			}, {
				ID:       6,
				Task:     "Test Task 6",
				Priority: "medium",
				Status:   "not_done",
				UserName: "rainbow777",
			},
		},
	},

	{
		Name:         "case3_low_NoData",
		QueryParam:   "?priority=low",
		Code:         http.StatusOK,
		ExpectedList: []structure.Todo{},
	},

	{
		Name:       "case4_2Priority",
		QueryParam: "?priority=high&priority=medium",
		Code:       http.StatusOK,
		ExpectedList: []structure.Todo{
			{
				ID:       1,
				Task:     "Test Task 1",
				Priority: "high",
				Status:   "not_done",
				UserName: "rainbow777",
			}, {
				ID:       2,
				Task:     "Test Task 2",
				Priority: "high",
				Status:   "done",
				UserName: "rainbow777",
			}, {
				ID:       3,
				Task:     "Test Task 3",
				Priority: "high",
				Status:   "not_done",
				UserName: "rainbow777",
			}, {
				ID:       4,
				Task:     "Test Task 4",
				Priority: "medium",
				Status:   "not_done",
				UserName: "rainbow777",
			}, {
				ID:       5,
				Task:     "Test Task 5",
				Priority: "medium",
				Status:   "done",
				UserName: "rainbow777",
			}, {
				ID:       6,
				Task:     "Test Task 6",
				Priority: "medium",
				Status:   "not_done",
				UserName: "rainbow777",
			},
		},
	},

	{
		Name:       "case5_Status_done",
		QueryParam: "?status=done",
		Code:       http.StatusOK,
		ExpectedList: []structure.Todo{
			{
				ID:       2,
				Task:     "Test Task 2",
				Priority: "high",
				Status:   "done",
				UserName: "rainbow777",
			}, {
				ID:       5,
				Task:     "Test Task 5",
				Priority: "medium",
				Status:   "done",
				UserName: "rainbow777",
			},
		},
	},

	{
		Name:       "case6_Status_not_done",
		QueryParam: "?status=not_done",
		Code:       http.StatusOK,
		ExpectedList: []structure.Todo{
			{
				ID:       1,
				Task:     "Test Task 1",
				Priority: "high",
				Status:   "not_done",
				UserName: "rainbow777",
			}, {
				ID:       3,
				Task:     "Test Task 3",
				Priority: "high",
				Status:   "not_done",
				UserName: "rainbow777",
			}, {
				ID:       4,
				Task:     "Test Task 4",
				Priority: "medium",
				Status:   "not_done",
				UserName: "rainbow777",
			}, {
				ID:       6,
				Task:     "Test Task 6",
				Priority: "medium",
				Status:   "not_done",
				UserName: "rainbow777",
			},
		},
	},

	{
		Name:       "case7_Status_all",
		QueryParam: "?status=all",
		Code:       http.StatusOK,
		ExpectedList: []structure.Todo{
			{
				ID:       1,
				Task:     "Test Task 1",
				Priority: "high",
				Status:   "not_done",
				UserName: "rainbow777",
			}, {
				ID:       2,
				Task:     "Test Task 2",
				Priority: "high",
				Status:   "done",
				UserName: "rainbow777",
			}, {
				ID:       3,
				Task:     "Test Task 3",
				Priority: "high",
				Status:   "not_done",
				UserName: "rainbow777",
			}, {
				ID:       4,
				Task:     "Test Task 4",
				Priority: "medium",
				Status:   "not_done",
				UserName: "rainbow777",
			}, {
				ID:       5,
				Task:     "Test Task 5",
				Priority: "medium",
				Status:   "done",
				UserName: "rainbow777",
			}, {
				ID:       6,
				Task:     "Test Task 6",
				Priority: "medium",
				Status:   "not_done",
				UserName: "rainbow777",
			},
		},
	},

	{
		Name:       "case8_NoQuery",
		QueryParam: "",
		Code:       http.StatusOK,
		ExpectedList: []structure.Todo{
			{
				ID:       1,
				Task:     "Test Task 1",
				Priority: "high",
				Status:   "not_done",
				UserName: "rainbow777",
			}, {
				ID:       3,
				Task:     "Test Task 3",
				Priority: "high",
				Status:   "not_done",
				UserName: "rainbow777",
			}, {
				ID:       4,
				Task:     "Test Task 4",
				Priority: "medium",
				Status:   "not_done",
				UserName: "rainbow777",
			}, {
				ID:       6,
				Task:     "Test Task 6",
				Priority: "medium",
				Status:   "not_done",
				UserName: "rainbow777",
			},
		},
	},

	{
		Name:       "case9_BadParam_hig",
		QueryParam: "?priority=hig",
		Code:       http.StatusBadRequest,
		ExpectedError: myerrors.MyAppError{
			ErrCode: myerrors.BadQuery,
			Message: "priority requier high or medium or low",
		},
	},

	{
		Name:       "case10_BadParam_notdone",
		QueryParam: "?status=notdone",
		Code:       http.StatusBadRequest,
		ExpectedError: myerrors.MyAppError{
			ErrCode: myerrors.BadQuery,
			Message: "Status must be all, done, not_done",
		},
	},

	{
		Name:       "case11_BadParam_2Status",
		QueryParam: "?status=done&status=not_done",
		Code:       http.StatusBadRequest,
		ExpectedError: myerrors.MyAppError{
			ErrCode: myerrors.BadQuery,
			Message: "Status must be only one parameter",
		},
	},

	{
		Name:       "case12_BadParam_page=a",
		QueryParam: "?page=a",
		Code:       http.StatusBadRequest,
		ExpectedError: myerrors.MyAppError{
			ErrCode: myerrors.BadQuery,
			Message: "page must be a valid number",
		},
	},

	{
		Name:       "case13_BadParam_page=0",
		QueryParam: "?page=0",
		Code:       http.StatusBadRequest,
		ExpectedError: myerrors.MyAppError{
			ErrCode: myerrors.BadQuery,
			Message: "Page number must be 1 or more",
		},
	},

	{
		Name:       "case15_BadQuery_2pages",
		QueryParam: "?page=1&page=3",
		Code:       http.StatusBadRequest,
		ExpectedError: myerrors.MyAppError{
			ErrCode: myerrors.BadQuery,
			Message: "Only one page can be specified at a time",
		},
	},

	{
		Name:       "case15_BadQuery_LimitOver",
		QueryParam: "?page=9999999",
		Code:       http.StatusBadRequest,
		ExpectedError: myerrors.MyAppError{
			ErrCode: myerrors.BadQuery,
			Message: "You can specify a maximum of 1000 pages",
		},
	},

	{
		Name:       "case14_Bad_QueryName",
		QueryParam: "?prioriti=high",
		Code:       http.StatusBadRequest,
		ExpectedError: myerrors.MyAppError{
			ErrCode: myerrors.BadQuery,
			Message: "Query name must be priority or status or page",
		},
	},

	{
		Name:       "case15_MixedBadQueryName",
		QueryParam: "?priority=medium&badquery=high",
		Code:       http.StatusBadRequest,
		ExpectedError: myerrors.MyAppError{
			ErrCode: myerrors.BadQuery,
			Message: "Query name must be priority or status or page",
		},
	},

	{
		Name:       "case7_Status_all",
		QueryParam: "?status=All",
		Code:       http.StatusOK,
		ExpectedList: []structure.Todo{
			{
				ID:       1,
				Task:     "Test Task 1",
				Priority: "high",
				Status:   "not_done",
				UserName: "rainbow777",
			}, {
				ID:       2,
				Task:     "Test Task 2",
				Priority: "high",
				Status:   "done",
				UserName: "rainbow777",
			}, {
				ID:       3,
				Task:     "Test Task 3",
				Priority: "high",
				Status:   "not_done",
				UserName: "rainbow777",
			}, {
				ID:       4,
				Task:     "Test Task 4",
				Priority: "medium",
				Status:   "not_done",
				UserName: "rainbow777",
			}, {
				ID:       5,
				Task:     "Test Task 5",
				Priority: "medium",
				Status:   "done",
				UserName: "rainbow777",
			}, {
				ID:       6,
				Task:     "Test Task 6",
				Priority: "medium",
				Status:   "not_done",
				UserName: "rainbow777",
			},
		},
	},
}
package testdata

import (
	"net/http"

	"github.com/rainbow777/todolist/myerrors"
	"github.com/rainbow777/todolist/structure"
)

// GetTaskHandler用テストデータ
type GetTaskTestData struct {
	Name          string
	Code          int
	ID            string
	ExpectedTask  structure.Todo      // 成功時のみ使用
	ExpectedError myerrors.MyAppError //失敗時のみ使用
}

var GetTaskTestCases = []GetTaskTestData{

	{
		Name: "case1_Success",
		Code: http.StatusOK,
		ID:   "1",
		ExpectedTask: structure.Todo{
			ID:       1,
			Task:     "Test Task 1",
			Priority: "high",
			Status:   "not_done",
			UserName: "rainbow777",
		},
	},
	{
		Name: "case2_Success",
		Code: http.StatusOK,
		ID:   "2",
		ExpectedTask: structure.Todo{
			ID:       2,
			Task:     "Test Task 2",
			Priority: "medium",
			Status:   "not_done",
			UserName: "rainbow777",
		},
	},
	{
		Name: "case3_NaData",
		Code: http.StatusNotFound,
		ID:   "3",
		ExpectedError: myerrors.MyAppError{
			ErrCode: myerrors.NAData,
			Message: "no data",
		},
	},
	{
		Name: "case4_Invalid",
		Code: http.StatusBadRequest,
		ID:   "aaa",
		ExpectedError: myerrors.MyAppError{
			ErrCode: myerrors.BadPath,
			Message: "invalid path parameter",
		},
	},
}
